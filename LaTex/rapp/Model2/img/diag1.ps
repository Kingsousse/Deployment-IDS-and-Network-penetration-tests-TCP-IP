%!PS-Adobe-2.0
%%Creator: dvips(k) 5.96dev Copyright 2007 Radical Eye Software
%%Title: diag1
%%CreationDate: Wed May 05 14:38:32 2010
%%Pages: 1
%%PageOrder: Ascend
%%BoundingBox: 0 0 616 177
%%DocumentFonts: NimbusRomNo9L-Medi NimbusRomNo9L-Regu
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -Pdownload35 -T
%+ 21.71483546721588cm,6.234835469600069cm diag1 -o
%+ "C:\Documents and Settings\Oussema\Bureau\rapp\img\diag1.ps"
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2010.05.05:1438
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/p{show}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0 N/Ry 0 N/V{}B/RV/v{
/Ry X/Rx X V}B statusdict begin/product where{pop false[(Display)(NeXT)
(LaserWriter 16/600)]{A length product length le{A length product exch 0
exch getinterval eq{pop true exit}if}{pop}ifelse}forall}{false}ifelse
end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{BDot}imagemask
grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat{BDot}
imagemask grestore}}ifelse B/QV{gsave newpath transform round exch round
exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0 rlineto
fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B/M{S p
delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}B/g{0 M}
B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p -3 w}B/n{
p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{0 S
rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
%!
% PostScript prologue for pstricks.tex.
% Version 1.01, 2006/01/11
% For distribution, see pstricks.tex.
%
/tx@Dict 200 dict def tx@Dict begin
/ADict 25 dict def
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, epects 2 parameter
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
%----------------- hv added 20050516 ---------------
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
/RadtoDeg { 180 mul Pi div } bind def % convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def % viceversa
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
/PathLength { flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def
  }{ /y ED /x ED PathLength@ } {} { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if z } def
/STP { .996264 dup scale } def
/STV { SDict begin normalscale end STP  } def
%
%%-------------- DG begin patch 15 ---------------%%
%/DashLine { dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def
%PathLength } ifelse /b ED /x ED /y ED /z y x add def b a .5 sub 2 mul y
%mul sub z Div round z mul a .5 sub 2 mul y mul add b exch Div dup y mul
%/y ED x mul /x ED x 0 gt y 0 gt and { [ y x ] 1 a sub y mul } { [ 1 0 ]
%0 } ifelse setdash stroke } def
/DashLine {
  dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def PathLength } ifelse
  /b ED /x1 ED /y1 ED /x ED /y ED 
  /z y x add y1 add x1 add def
  /Coef b a .5 sub 2 mul y mul sub z Div round 
    z mul a .5 sub 2 mul y mul add b exch Div def 
  /y y Coef mul def 
  /x x Coef mul def 
  /y1 y1 Coef mul def 
  /x1 x1 Coef mul def
  x1 0 gt y1 0 gt or x 0 gt or y 0 gt and 
    { [ y x y1 x1 ] 1 a sub y mul }
    { [ 1 0 ] 0 } ifelse 
  setdash stroke
} def
%%-------------- DG end patch 15 ---------------%%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
%gsave abs CLW add /a ED a 0 dtransform round exch round exch
%2 copy idtransform exch Atan rotate idtransform pop /a ED .25 .25
%% DG/SR modification begin - Dec. 12, 1997 - Patch 2
%%itransform translate pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
%itransform pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
%% DG/SR modification end
%Div cvi /x1 ED /y2 y2 y1 sub def clip newpath 2 setlinecap systemdict
%/setstrokeadjust known { true setstrokeadjust } if x2 x1 sub 1 add { x1
%% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
%% a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore }
%% def
%a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore
%pop pop } def
%% DG/SR modification end
%
/BeginArrow { ADict begin /@mtrx CM def gsave 2 copy T 2 index sub neg
exch 3 index sub exch Atan rotate newpath } def
/EndArrow { @mtrx setmatrix CP grestore end } def
/Arrow { CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1
scale } if w neg h moveto 0 0 L w h L w neg a neg rlineto gsave fill
grestore } def
/Tbar { CLW mul add /z ED z -2 div CLW 2 div moveto z 0 rlineto stroke 0
CLW moveto } def
/Bracket { CLW mul add dup CLW sub 2 div /x ED mul CLW add /y ED /z CLW 2
div def x neg y moveto x neg CLW 2 div L x CLW 2 div L x y L stroke 0
CLW moveto } def
/RoundBracket { CLW mul add dup 2 div /x ED mul /y ED /mtrx CM def 0 CLW
2 div T x y mul 0 ne { x y scale } if 1 1 moveto .85 .5 .35 0 0 0
curveto -.35 0 -.85 .5 -1 1 curveto mtrx setmatrix stroke 0 CLW moveto }
def
/SD { 0 360 arc fill } def
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse 
  /b ED 0 z DS SD b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub moveto } def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { aload length 2 div dup dup cvi eq not { exch pop } if /n exch
cvi def } def
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
/Arcto { /a [ 6 -2 roll ] cvx def a r /arcto load stopped { 5 } { 4 }
  ifelse { pop } repeat a } def
/CheckClosed { dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if } def
/Polygon { NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop }
  repeat } { n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1
  ED /x1 ED x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1
  moveto /n n 2 sub def n { Lineto } repeat x1 y1 x0 y0 6 4 roll Lineto
  Lineto pop pop closepath } ifelse } def
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
% DG modification begin - Jan. 15, 1997
%/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup 0 eq {
%pop } { CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
%div dup cos exch sin Div mul sub def } ifelse mark 0 d w neg d 0 h w d 0
%d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
%setmatrix } def
/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup
CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
div dup cos exch sin Div mul sub def mark 0 d w neg d 0 h w d 0
d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
setmatrix pop } def
% DG/SR modification end
/CCA { /y ED /x ED 2 copy y sub /dy1 ED x sub /dx1 ED /l1 dx1 dy1 Pyth
def } def
/CCA { /y ED /x ED 2 copy y sub /dy1 ED x sub /dx1 ED /l1 dx1 dy1 Pyth
def } def
/CC { /l0 l1 def /x1 x dx sub def /y1 y dy sub def /dx0 dx1 def /dy0 dy1
def CCA /dx dx0 l1 c exp mul dx1 l0 c exp mul add def /dy dy0 l1 c exp
mul dy1 l0 c exp mul add def /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos
abs b exp a mul dx dy Pyth Div 2 div def /x2 x l0 dx mul m mul sub def
/y2 y l0 dy mul m mul sub def /dx l1 dx mul m mul neg def /dy l1 dy mul
m mul neg def } def
/IC { /c c 1 add def c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if }
ifelse /a a 2 mul 3 div 45 cos b exp div def CCA /dx 0 def /dy 0 def }
def
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
/AltCurve { { false NArray n 2 mul 2 roll [ n 2 mul 3 sub 1 roll ] aload
/Points ED n 2 mul -2 roll } { false NArray } ifelse n 4 lt { n { pop
pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse } def
/ClosedCurve { NArray n 3 lt { n { pop pop } repeat } { n 3 gt {
CheckClosed } if 6 copy n 2 mul 6 add 6 roll IC CC x y moveto n { NC }
repeat closepath pop pop } ifelse } def
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore }
def
/FontDot { DS 2 mul dup matrix scale matrix concatmatrix exch matrix
rotate matrix concatmatrix exch findfont exch makefont setfont } def
/Rect { x1 y1 y2 add 2 div moveto x1 y2 lineto x2 y2 lineto x2 y1 lineto
x1 y1 lineto closepath } def
/OvalFrame { x1 x2 eq y1 y2 eq or { pop pop x1 y1 moveto x2 y2 L } { y1
y2 sub abs x1 x2 sub abs 2 copy gt { exch pop } { pop } ifelse 2 div
exch { dup 3 1 roll mul exch } if 2 copy lt { pop } { exch pop } ifelse
/b ED x1 y1 y2 add 2 div moveto x1 y2 x2 y2 b arcto x2 y2 x2 y1 b arcto
x2 y1 x1 y1 b arcto x1 y1 x1 y2 b arcto 16 { pop } repeat closepath }
ifelse } def
/Frame { CLW mul /a ED 3 -1 roll 2 copy gt { exch } if a sub /y2 ED a add
/y1 ED 2 copy gt { exch } if a sub /x2 ED a add /x1 ED 1 index 0 eq {
pop pop Rect } { OvalFrame } ifelse } def
/BezierNArray { /f ED counttomark 2 div dup cvi /n ED n eq not { exch pop
} if n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat f { ]
aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse } def
/OpenBezier { BezierNArray n 1 eq { pop pop } { ArrowA n 4 sub 3 idiv { 6
2 roll 4 2 roll curveto } repeat 6 2 roll 4 2 roll ArrowB curveto }
ifelse } def
/ClosedBezier { BezierNArray n 1 eq { pop pop } { moveto n 1 sub 3 idiv {
6 2 roll 4 2 roll curveto } repeat closepath } ifelse } def
/BezierShowPoints { gsave Points aload length 2 div cvi /n ED moveto n 1
sub { lineto } repeat CLW 2 div SLW [ 4 4 ] 0 setdash stroke grestore }
def
/Parab { /y0 exch def /x0 exch def /y1 exch def /x1 exch def /dx x0 x1
sub 3 div def /dy y0 y1 sub 3 div def x0 dx sub y0 dy add x1 y1 ArrowA
x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB curveto /Points [ x1 y1 x0
y0 x0 2 mul x1 sub y1 ] def } def
/Grid { newpath /a 4 string def /b ED /c ED /n ED cvi dup 1 lt { pop 1 }
if /s ED s div dup 0 eq { pop 1 } if /dy ED s div dup 0 eq { pop 1 } if
/dx ED dy div round dy mul /y0 ED dx div round dx mul /x0 ED dy div
round cvi /y2 ED dx div round cvi /x2 ED dy div round cvi /y1 ED dx div
round cvi /x1 ED /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def /w x2 x1 sub
0 gt { 1 } { -1 } ifelse def b 0 gt { /z1 b 4 div CLW 2 div add def
/Helvetica findfont b scalefont setfont /b b .95 mul CLW 2 div add def }
if systemdict /setstrokeadjust known { true setstrokeadjust /t { } def }
{ /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
exch itransform } bind def } ifelse gsave n 0 gt { 1 setlinecap [ 0 dy n
div ] dy n div 2 div setdash } { 2 setlinecap } ifelse /i x1 def /f y1
dy mul n 0 gt { dy n div 2 div h mul sub } if def /g y2 dy mul n 0 gt {
dy n div 2 div h mul add } if def x2 x1 sub w mul 1 add dup 1000 gt {
pop 1000 } if { i dx mul dup y0 moveto b 0 gt { gsave c i a cvs dup
stringwidth pop /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse h 0 gt {b neg}
{z1} ifelse rmoveto show grestore } if dup t f moveto g t L stroke /i i
w add def } repeat grestore gsave n 0 gt
% DG/SR modification begin - Nov. 7, 1997 - Patch 1
%{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
{ 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
% DG/SR modification end
{ 2 setlinecap } ifelse /i y1 def /f x1 dx mul
n 0 gt { dx n div 2 div w mul sub } if def /g x2 dx mul n 0 gt { dx n
div 2 div w mul add } if def y2 y1 sub h mul 1 add dup 1000 gt { pop
1000 } if { newpath i dy mul dup x0 exch moveto b 0 gt { gsave c i a cvs
dup stringwidth pop /z2 ED w 0 gt {z1 z2 add neg} {z1} ifelse h 0 gt
{z1} {b neg} ifelse rmoveto show grestore } if dup f exch t moveto g
exch t L stroke /i i h add def } repeat grestore } def
/ArcArrow { /d ED /b ED /a ED gsave newpath 0 -1000 moveto clip newpath 0
1 0 0 b grestore c mul /e ED pop pop pop r a e d PtoC y add exch x add
exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
mul neg d } def
/Ellipse { /mtrx CM def T scale 0 0 1 5 3 roll arc mtrx setmatrix } def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % add/sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul x add
  a2 sin ry mul y add
  a1 cos rx mul x add
  a1 sin ry mul y add
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
/RotBegin { tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 }
def } if /TMatrix [ TMatrix CM ] cvx def /a ED a Rot /RAngle [ RAngle
dup a add ] cvx def } def
/RotEnd { /TMatrix [ TMatrix setmatrix ] cvx def /RAngle [ RAngle pop ]
cvx def } def
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
/Uput { /a ED add 2 div /h ED 2 div /w ED /s a sin def /c a cos def /b s
abs c abs 2 copy gt dup /q ED { pop } { exch pop } ifelse def /w1 c b
div w mul def /h1 s b div h mul def q { w1 abs w sub dup c mul abs } {
h1 abs h sub dup s mul abs } ifelse } def
/UUput { /z ED abs /y ED /x ED q { x s div c mul abs y gt } { x c div s
mul abs y gt } ifelse { x x mul y y mul sub z z mul add sqrt z add } { q
{ x s div } { x c div } ifelse abs } ifelse a PtoC h1 add exch w1 add
exch } def
/BeginOL { dup (all) eq exch TheOL eq or { IfVisible not { Visible
/IfVisible true def } if } { IfVisible { Invisible /IfVisible false def
} if } ifelse } def
/InitOL { /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
/Visible { CP OLUnit idtransform T moveto } def /Invisible { CP OLUnit
neg exch neg exch idtransform T moveto } def /BOL { BeginOL } def
/IfVisible true def } def
end
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
%!
%% PostScript prologue for pstricks.tex.
%% Version 2.00,                                    Suggestion of 2006/12/19
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Herbert Voss (hv) - 2004/12/27 
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%
10 dict dup begin
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
  /FontBBox [-571.5 -742.5 571.5 742.5] def
%  /FontBBox [-1000 -1000 1000 1000] def
%                See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch/.notdef put} for
  Encoding
    dup (b) 0 get /Bullet put
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
  CharProcs begin
    /CirclePath {0 0 500 0 360 arc closepath} def
      /Bullet {CirclePath fill} def
	  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
	  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
    /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto
		closepath} def
	  /SolidTriangle {TrianglePath fill} def
      /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
      /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
    /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto
		closepath} def
      /SolidSquare {SquarePath fill} def
      /Square {SquarePath .89 .89 scale SquarePath eofill} def
      /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
    /PentagonPath {-337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
		0 574.7 lineto -546.6 177.6 lineto closepath} def
      /SolidPentagon {PentagonPath fill} def
      /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
      /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
    /HexagonPath {0 550 moveto -476 275 lineto -476 -275 lineto
		0 -550 lineto 476 -275 lineto 476 275 lineto closepath} def
      /SolidHexagon {HexagonPath fill} def
      /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
      /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
	/AsteriskPath {20 0 moveto 10 250 180 500 0 500 curveto
		-180 500 -10 250 -20 0 curveto closepath} def
      /Asterisk {AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
	    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath 
		fill} def
	/Basterp {50 250 220 500 0 500 curveto
        -220 500 -50 250 -50 30 cos 100 mul curveto} def
	/BoldAsteriskPath {50 30 cos 100 mul moveto  Basterp
                     60 rotate Basterp 60 rotate Basterp
                     60 rotate Basterp 60 rotate Basterp
                     60 rotate Basterp closepath} def
      /BoldAsterisk {BoldAsteriskPath fill} def
	  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
    /CrossPath {40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
        -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
		40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath} def
    /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
        -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
		80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath} def
      /Add {CrossPath fill} def
      /Mul {45 rotate CrossPath fill} def
      /BoldAdd {BoldCrossPath fill} def
      /BoldMul {45 rotate BoldCrossPath fill} def
	  /Oplus {CirclePath .9 .9 scale CirclePath eofill
		.775 .775 scale CrossPath  fill} def 
	  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
	  /BOplus {CirclePath .8 .8 scale CirclePath eofill
		.775 .775 scale BoldCrossPath fill} def 
	  /Otimes {CirclePath .9 .9 scale CirclePath eofill
		45 rotate .775 .775 scale CrossPath fill} def 
	  /BOtimes {CirclePath .8 .8 scale CirclePath eofill
		45 rotate .775 .775 scale BoldCrossPath  fill } def 
	  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
    /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto
		closepath} def
      /Bar {BarPath fill} def
    /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto
		closepath} def
      /BoldBar {BoldBarPath fill} def
    /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 
		428.5 0 lineto closepath} def
      /SolidDiamond {DiamondPath fill} def
      /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
      /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
    /.notdef { } def
  end
  /BuildGlyph {
    exch
    begin
%      Metrics 1 index get exec 0
       0 0
%      BBoxes 3 index get exec
      -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
      setcachedevice
      CharProcs begin load exec end
    end
  } def
  /BuildChar {
    1 index /Encoding get exch get
    1 index /BuildGlyph get exec
  } bind def
end
/PSTricksDotFont exch definefont pop


%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
%!
% PostScript prologue for pst-node.tex.
% Version 97 patch 1, 97/05/09.
% For distribution, see pstricks.tex.
%
/tx@NodeDict 400 dict def tx@NodeDict begin
tx@Dict begin /T /translate load def end
/NewNode { gsave /next ED dict dup 3 1 roll def exch { dup 3 1 roll def }
if begin tx@Dict begin STV CP T exec end /NodeMtrx CM def next end
grestore } def
/InitPnode { /Y ED /X ED /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
/InitCnode { /r ED /Y ED /X ED /NodePos { NodeSep r add dup Cos mul exch
Sin mul } def } def
/GetRnodePos { Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def
} ifelse Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def }
ifelse dx Sin mul abs dy Cos mul abs gt { dy Cos mul Sin div dy } { dx
dup Sin mul Cos Div } ifelse } def
/InitRnode { /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub
/u ED /NodePos { GetRnodePos } def } def
/DiaNodePos { w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
Cos mul exch Sin mul } def
/TriNodePos { Sin s lt { d NodeSep sub dup Cos mul Sin Div exch } { w h
mul w Sin mul h Cos abs mul add Div NodeSep add dup Cos mul exch Sin mul
} ifelse } def
/InitTriNode { sub 2 div exch 2 div exch 2 copy T 2 copy 4 index index /d
ED pop pop pop pop -90 mul rotate /NodeMtrx CM def /X 0 def /Y 0 def d
sub abs neg /d ED d add /h ED 2 div h mul h d sub Div /w ED /s d w Atan
sin def /NodePos { TriNodePos } def } def
/OvalNodePos { /ww w NodeSep add def /hh h NodeSep add def Sin ww mul Cos
hh mul Atan dup cos ww mul exch sin hh mul } def
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
/XYPos { dup sin exch cos Do /Cos ED /Sin ED /Dist ED Cos 0 gt { Dist
Dist Sin mul Cos div } { Cos 0 lt { Dist neg Dist Sin mul Cos div neg }
{ 0 Dist Sin mul } ifelse } ifelse Do } def
/GetEdge { dup 0 eq { pop begin 1 0 NodeMtrx dtransform CM idtransform
exch atan sub dup sin /Sin ED cos /Cos ED /NodeSep ED NodePos NodeMtrx
dtransform CM idtransform end } { 1 eq {{exch}} {{}} ifelse /Do ED pop
XYPos } ifelse } def
/AddOffset { 1 index 0 eq { pop pop } { 2 copy 5 2 roll cos mul add 4 1
roll sin mul sub exch } ifelse } def
/GetEdgeA { NodeSepA AngleA NodeA NodeSepTypeA GetEdge OffsetA AngleA
AddOffset yA add /yA1 ED xA add /xA1 ED } def
/GetEdgeB { NodeSepB AngleB NodeB NodeSepTypeB GetEdge OffsetB AngleB
AddOffset yB add /yB1 ED xB add /xB1 ED } def
/GetArmA { ArmTypeA 0 eq { /xA2 ArmA AngleA cos mul xA1 add def /yA2 ArmA
AngleA sin mul yA1 add def } { ArmTypeA 1 eq {{exch}} {{}} ifelse /Do ED
ArmA AngleA XYPos OffsetA AngleA AddOffset yA add /yA2 ED xA add /xA2 ED
} ifelse } def
/GetArmB { ArmTypeB 0 eq { /xB2 ArmB AngleB cos mul xB1 add def /yB2 ArmB
AngleB sin mul yB1 add def } { ArmTypeB 1 eq {{exch}} {{}} ifelse /Do ED
ArmB AngleB XYPos OffsetB AngleB AddOffset yB add /yB2 ED xB add /xB2 ED
} ifelse } def
/InitNC { /b ED /a ED /NodeSepTypeB ED /NodeSepTypeA ED /NodeSepB ED
/NodeSepA ED /OffsetB ED /OffsetA ED tx@NodeDict a known tx@NodeDict b
known and dup { /NodeA a load def /NodeB b load def NodeA GetCenter /yA
ED /xA ED NodeB GetCenter /yB ED /xB ED } if } def
/LPutLine { 4 copy 3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 1 t sub
mul 3 1 roll 1 t sub mul 4 1 roll t mul add /Y ED t mul add /X ED } def
/LPutLines { mark LPutVar counttomark 2 div 1 sub /n ED t floor dup n gt
{ pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse cvi 2 mul { pop
} repeat LPutLine cleartomark } def
/BezierMidpoint { /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED
/t ED /cx x1 x0 sub 3 mul def /cy y1 y0 sub 3 mul def /bx x2 x1 sub 3
mul cx sub def /by y2 y1 sub 3 mul cy sub def /ax x3 x0 sub cx sub bx
sub def /ay y3 y0 sub cy sub by sub def ax t 3 exp mul bx t t mul mul
add cx t mul add x0 add ay t 3 exp mul by t t mul mul add cy t mul add
y0 add 3 ay t t mul mul mul 2 by t mul mul add cy add 3 ax t t mul mul
mul 2 bx t mul mul add cx add atan /NAngle ED /Y ED /X ED } def
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
/HPutLines { HPosBegin yB yA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { dup Y check { exit
} { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark HPosEnd 
} def
/VPosBegin { xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def } def
/NCCoor { /AngleA yB yA sub xB xA sub Atan def /AngleB AngleA 180 add def
GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def /LPutPos {
LPutVar LPutLine } def /HPutPos { LPutVar HPutLine } def /VPutPos {
LPutVar VPutLine } def LPutVar } def
/NCLine { NCCoor tx@Dict begin ArrowA CP 4 2 roll ArrowB lineto pop pop
end } def
/NCLines { false NArray n 0 eq { NCLine } { 2 copy yA sub exch xA sub
Atan /AngleA ED n 2 mul dup index exch index yB sub exch xB sub Atan
/AngleB ED GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1
yA1 ] cvx def mark LPutVar tx@Dict begin false Line end /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
ifelse } def
/NCCurve { GetEdgeA GetEdgeB xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
/NCAngles { GetEdgeA GetEdgeB GetArmA GetArmB /mtrx AngleA matrix rotate
def xA2 yA2 mtrx transform pop xB2 yB2 mtrx transform exch pop mtrx
itransform /y0 ED /x0 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2 x0 y0 xA2
yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin false Line end /LPutVar [ xB1
yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def /LPutPos { LPutLines } def
/HPutPos { HPutLines } def /VPutPos { VPutLines } def } def
/NCAngle { GetEdgeA GetEdgeB GetArmB /mtrx AngleA matrix rotate def xB2
yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
/y0 ED /x0 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2 x0 y0 xA1 yA1
tx@Dict begin false Line end /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ]
cvx def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
/NCBar { GetEdgeA GetEdgeB GetArmA GetArmB /mtrx AngleA matrix rotate def
xA2 yA2 mtrx itransform pop xB2 yB2 mtrx itransform pop sub dup 0 mtrx
transform 3 -1 roll 0 gt { /yB2 exch yB2 add def /xB2 exch xB2 add def }
{ /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse mark ArmB
0 ne { xB1 yB1 } if xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict
begin false Line end /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx
def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
/NCDiag { GetEdgeA GetEdgeB GetArmA GetArmB mark ArmB 0 ne { xB1 yB1 } if
xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin false Line end
/LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
def
/NCDiagg { GetEdgeA GetArmA yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
GetEdgeB mark xB1 yB1 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin
false Line end /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
def
/NCLoop { GetEdgeA GetEdgeB GetArmA GetArmB /mtrx AngleA matrix rotate
def xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED /xB3 xB2 yB2
mtrx transform pop def xB3 yA3 mtrx itransform /yB3 ED /xB3 ED xA3 yA3
mtrx itransform /yA3 ED /xA3 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2
xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin false
Line end /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ]
cvx def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
/NCCircle { NodeSepA 0 NodeA 0 GetEdge pop 2 div dup 2 exp r
r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
mul add dup 5 1 roll 90 sub PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
% DG/SR modification end
} def /HPutPos { LPutPos } def /VPutPos { LPutPos } def r AngleA 90 sub a add
AngleA 270 add a sub tx@Dict begin /angleB ED /angleA ED /r ED /c 57.2957 r
Div def /y ED /x ED } def
/NCBox { /d ED /h ED /AngleB yB yA sub xB xA sub Atan def /AngleA AngleB
180 add def GetEdgeA GetEdgeB /dx d AngleB sin mul def /dy d AngleB cos
mul neg def /hx h AngleB sin mul neg def /hy h AngleB cos mul def
/LPutVar [ xA1 hx add yA1 hy add xB1 hx add yB1 hy add xB1 dx add yB1 dy
add xA1 dx add yA1 dy add ] cvx def /LPutPos { LPutLines } def /HPutPos
{ xB yB xA yA LPutLine } def /VPutPos { HPutPos } def mark LPutVar
tx@Dict begin false Polygon end } def
/NCArcBox { /l ED neg /d ED /h ED /a ED /AngleA yB yA sub xB xA sub Atan
def /AngleB AngleA 180 add def /tA AngleA a sub 90 add def /tB tA a 2
mul add def /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
/x0 xA r tA cos mul add def /y0 yA r tA sin mul add def /c 57.2958 r div
def /AngleA AngleA a sub 180 add def /AngleB AngleB a add 180 add def
GetEdgeA GetEdgeB /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul
sub def /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def l 0
eq { x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn }
{ x0 y0 translate /tA AngleA l c mul add def /tB AngleB l c mul sub def
0 0 r h add tA tB arc r h add AngleB PtoC r d add AngleB PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r d add tB PtoC l arcto 4 { pop } repeat 0
0 r d add tB tA arcn r d add AngleA PtoC r h add AngleA PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r h add tA PtoC l arcto 4 { pop } repeat }
ifelse closepath /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def /LPutPos
{ LPutVar /d ED /h ED /AngleB ED /AngleA ED /r ED /y0 ED /x0 ED t 1 le {
r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC }
{ t 2 lt { /NAngle AngleB 180 add def r 2 t sub h mul t 1 sub d mul add
add AngleB PtoC } { t 3 lt { r d add AngleB 3 t sub mul AngleA 2 t sub
mul add dup 90 sub /NAngle ED PtoC } { /NAngle AngleA 180 add def r 4 t
sub d mul t 3 sub h mul add add AngleA PtoC } ifelse } ifelse } ifelse
y0 add /Y ED x0 add /X ED } def /HPutPos { LPutPos } def /VPutPos {
LPutPos } def } def
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
/LPutCoor { NAngle tx@Dict begin /NAngle ED end gsave CM STV CP Y sub neg
exch X sub neg exch moveto setmatrix CP grestore } def
/LPut { tx@NodeDict /LPutPos known { LPutPos } { CP /Y ED /X ED /NAngle 0
def } ifelse LPutCoor  } def
/HPutAdjust { Sin Cos mul 0 eq { 0 } { d Cos mul Sin div flag not { neg }
if h Cos mul Sin div flag { neg } if 2 copy gt { pop } { exch pop }
ifelse } ifelse s add flag { r add neg } { l add } ifelse X add /X ED }
def
/VPutAdjust { Sin Cos mul 0 eq { 0 } { l Sin mul Cos div flag { neg } if
r Sin mul Cos div flag not { neg } if 2 copy gt { pop } { exch pop }
ifelse } ifelse s add flag { d add } { h add neg } ifelse Y add /Y ED }
def
end
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%!
% PostScript prologue for pstricks-add.tex.
% Version 0.14, 2007/09/17
% For distribution, see pstricks.tex.
%
%       HISTORY -> see file Changes
%
tx@Dict begin 	% make it global for TeX
%% Pi and Euler are defined in pstricks.pro
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 			% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 	% default sin/cos
} def
/PIdiv2 1.57079632680 def
%
%--------- will go later into pstricks.pro ------------
%
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
end
%
/tx@addDict 410 dict def tx@addDict begin
%%
%% parser
%% str -> [ LIFO vector ]
/AlgParser { tx@AlgToPs begin AlgToPs end } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >>
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % c m y k on stack
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { 
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanomÅËtres
%% lambda min=380 nanomÅËtres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def

systemdict /shfill known not {

/Emulate_shfill 32 dict def Emulate_shfill begin

/NumberOfLayers 128 def

/assert { not { (assert) /typecheck signalerror} if } bind def
/assert /pop load def

% generic interpolation
% takes two n-arrays, returns a hopefully optimized procedure taking one
% argument, and returning a correct blend of the two arrays (hence an
% n-array)
/interpolating_function {
    10 dict begin /a1 exch def /a0 exch def
    a0 length a1 length eq assert
    [ /mark load /exch load
    0 1 a0 length 1 sub { /i exch def /dup load a1 i get a0 i get sub /mul load a0 i get /add load /exch load } for /pop load (]) cvn load ] cvx end
} bind def

% Emulates (rather poorly) a radial or axial fill.
% For radial fills, we _require_ that the inner circle be specified
% first.
% For axial fills, the ``Extend'' behaviour is ignored, and we _require_
% an additional parameters in the dictionary, named EmulatorHints. It's a
% 2-array denoting the left and right extent of the area to paint. These
% are taken as multiples of the vector orthogonal to the direction vector.
/xshfill { begin gsave
    % do some checks.
    Function begin FunctionType 2 eq assert
    Domain 0 get 0 eq Domain 1 get 1 eq and assert end
    ColorSpace setcolorspace
    % we assume ll2 at least, so that dicts can be extended. anyway
    % the syntax we request is ll2 only.
    /mkcol Function begin C0 C1 end interpolating_function bind def
    ShadingType 3 eq {
        /mkcoords
        [ Coords cvx exec 7 3 roll ] [ 5 -3 roll ]
        interpolating_function
        bind def
        /one { newpath mkcoords cvx dup exec 3 -1 roll add exch moveto
        exec 0 360 arc fill } bind def
    } if
    ShadingType 2 eq {
        /dv [ Coords cvx exec exch 4 1 roll exch sub 3 1 roll sub exch
        ] cvx def % normal vector
        /nv [ dv neg exch ] cvx def
        /mkcoords
        [ Coords cvx exec 5 2 roll nv
        exch 4 -1 roll exch EmulatorHints 0 get mul add
        3 1 roll EmulatorHints 0 get mul add ]
        [ 4 -2 roll nv
        exch 4 -1 roll exch EmulatorHints 0 get mul add
        3 1 roll EmulatorHints 0 get mul add ]
        interpolating_function
        % rescale to adapt to our reverse scan behaviour.
        /dv [ dv neg NumberOfLayers div exch neg NumberOfLayers div exch ] cvx def
        /bnv [ nv EmulatorHints cvx exec add mul exch
        EmulatorHints cvx exec add mul exch  ] cvx def
        /nv [ bnv neg exch neg exch  ] cvx def
        bind def
        /one { newpath mkcoords cvx exec moveto
            nv rlineto 
            dv rlineto
            bnv rlineto 
            closepath fill } bind def
    } if
    % The space is traversed backwards, since it is more customary
    % for me at least to put the inner circle first for radial fills.
    % For axial fills, this does not matter afaict.
    1 1 NumberOfLayers div neg 0
    { dup Function /N get exp mkcol cvx exec setcolor one }
    for
    grestore end
} bind def

end
userdict /shfill { Emulate_shfill begin xshfill end } bind put } if

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.12
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E expression, T term, SF signed factor, F factor, P power
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% parser
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower IsEndingFactor { pop exit } if} loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.14159265359 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end%%%tx@CoreAnalyzerDict
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.14159265359 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if 90 div 1.57079632680 mul
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan 90 div 1.57079632680 mul
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if 90 div 1.57079632680 mul } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { 2.71828182846 exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/PI 3.14159265358 def
/e 2.71828182846 def
end
% END pstricks-add.pro



%%EndProcSet
%%BeginProcSet: pst-grad.pro 0 0
%!
% PostScript prologue for pst-grad.tex.
% Version 1.05, 2006/11/04 
% prepared by Herbert Voss
% For copying restrictions, see pstricks.tex.
%
% For the PSTricks gradient fillstyle.%
% Based on some EPS files by leeweyr!bill@nuchat.sccsi.com (W. R. Lee).%
% Syntax:% D.G. modification begin - Apr.  9, %1998
%%%%%% R0 G0 B0 R1 G1 B1 NumLines MidPoint Angle GradientFill
%   ifGradientCircle GradientScale %GradientPosX GradientPosY
%     R0 G0 B0 R1 G1 B1 NumLines MidPoint %Angle GradientFill
% D.G. modification end
%
/tx@GradientDict 40 dict def
tx@GradientDict begin
/GradientFill {
 /ifCMYK exch def   % do we have rgb or cmyk? hv 1.06
 rotate
 /MidPoint ED
 /NumLines ED
 ifCMYK {
    /LastBlack ED	% 1.06
    /LastYellow ED	% 1.06
    /LastMagenta ED	% 1.06
    /LastCyan ED	% 1.06
    /FirstBlack ED	% 1.06
    /FirstYellow ED	% 1.06
    /FirstMagenta ED	% 1.06
    /FirstCyan ED	% 1.06
 }{ /LastBlue ED
    /LastGreen ED
    /LastRed ED
    /FirstBlue ED
    /FirstGreen ED
    /FirstRed ED
 } ifelse
 /GradientPosY ED
 /GradientPosX ED
 /GradientScale ED
 /ifGradientCircle ED
 % This avoids gaps due to rounding errors:
 clip
 pathbbox           %leave llx,lly,urx,ury on stack
 4 copy /ury ED /urx ED /lly ED /llx ED
 /y ED /x ED
 ifGradientCircle
   { 0 GradientPosX eq { 0 GradientPosX eq {2 copy translate} if } if }
   {2 copy translate} ifelse
 y sub neg /y ED
 x sub neg /x ED  % This avoids gaps due to rounding errors:
 ifCMYK {				% 1.06
    LastCyan FirstCyan add 2 div	% 1.06
    LastMagenta FirstMagenta add 2 div	% 1.06
    LastYellow FirstYellow add 2 div	% 1.06
    LastBlack FirstBlack add 2 div	% 1.06
    setcmykcolor			% 1.06
  }{
    LastRed FirstRed add 2 div
    LastGreen FirstGreen add 2 div
    LastBlue FirstBlue add 2 div
    setrgbcolor
  } ifelse
 ifGradientCircle
   { /YSizePerLine y NumLines div def
     /CurrentY y 2 div def
     /MidLine NumLines 2 div 1 MidPoint sub mul abs cvi def
   }{
     fill
     /YSizePerLine y NumLines div def
     /CurrentY 0 def
     /MidLine NumLines 1 MidPoint sub mul abs cvi def
   } ifelse
 MidLine NumLines 2 sub gt 
   { /MidLine NumLines def }
   { MidLine 2 lt { /MidLine 0 def } if } ifelse
 MidLine 0 gt {
  ifCMYK {
    /Cyan FirstCyan def
    /Magenta FirstMagenta def
    /Yellow FirstYellow def
    /Black FirstBlack def
    /CyanIncrement LastCyan FirstCyan sub MidLine 1 sub div def
    /MagentaIncrement LastMagenta FirstMagenta sub MidLine 1 sub div def
    /YellowIncrement LastYellow FirstYellow sub MidLine 1 sub div def
    /BlackIncrement LastBlack FirstBlack sub MidLine 1 sub div def
  }{
    /Red FirstRed def
    /Green FirstGreen def
    /Blue FirstBlue def
    /RedIncrement LastRed FirstRed sub MidLine 1 sub div def
    /GreenIncrement LastGreen FirstGreen sub MidLine 1 sub div def
    /BlueIncrement LastBlue FirstBlue sub MidLine 1 sub div def
  } ifelse
  MidLine { GradientLoop } repeat
 } if
 MidLine NumLines lt {
  ifCMYK {
    /Cyan LastCyan def
    /Magenta LastMagenta def
    /Yellow LastYellow def
    /Black LastBlack def
    /CyanIncrement FirstCyan LastCyan sub NumLines MidLine sub 1 sub div def
    /MagentaIncrement FirstMagenta LastMagenta sub NumLines MidLine sub 1 sub div def
    /YellowIncrement FirstYellow LastYellow sub NumLines MidLine sub 1 sub div def
    /BlackIncrement FirstBlack LastBlack sub NumLines MidLine sub 1 sub div def
  }{
    /Red LastRed def
    /Green LastGreen def
    /Blue LastBlue def
    /RedIncrement FirstRed LastRed sub NumLines MidLine sub 1 sub div def
    /GreenIncrement FirstGreen LastGreen sub NumLines MidLine sub 1 sub div def
    /BlueIncrement FirstBlue LastBlue sub NumLines MidLine sub 1 sub div def
  } ifelse
  NumLines MidLine sub { GradientLoop } repeat  
 } if
} def/GradientLoop {
% D.G. modification begin - Jul. 23, 1997 / Apr.  9, 1998
  ifGradientCircle
   {CurrentY 0 gt {
% The default center used is the center of the bounding box of the object
      0 GradientPosX eq        {0 GradientPosX eq
           {/GradientPosX urx llx sub 2 div def
            /GradientPosY ury lly sub 2 div def} if} if
      GradientPosX GradientPosY CurrentY GradientScale mul 0 360 arc
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill
      /CurrentY CurrentY YSizePerLine sub def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
  } if }   { 0 CurrentY moveto    x 0 rlineto
    0 YSizePerLine rlineto    x neg 0 rlineto    closepath
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill    
      /CurrentY CurrentY YSizePerLine add def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
      } ifelse% D.G. modification end
    }def
%
/GradientFillHSB { %	hv 2006-11-04
  rotate
  /MidPoint ED
  /NumLines ED
  /LastBrightness ED
  /LastSaturation ED
  /LastHue ED
  /FirstBrightness ED
  /FirstSaturation ED
  /FirstHue ED
  % This avoids gaps due to rounding errors:
  clip
  pathbbox           %leave llx,lly,urx,ury on stack
  /y ED /x ED
  2 copy translate
  y sub neg /y ED
  x sub neg /x ED
  % This avoids gaps due to rounding errors:
  LastHue FirstHue add 2 div
  LastSaturation FirstSaturation add 2 div
  LastBrightness FirstBrightness add 2 div
  sethsbcolor
  fill
  /YSizePerLine y NumLines div def
  /CurrentY 0 def
  /MidLine NumLines 1 MidPoint sub mul abs cvi def
  MidLine NumLines 2 sub gt
  { /MidLine NumLines def }
  { MidLine 2 lt { /MidLine 0 def } if }
  ifelse
  MidLine 0 gt
  {
    /Hue FirstHue def
    /Saturation FirstSaturation def
    /Brightness FirstBrightness def
    /HueIncrement LastHue FirstHue sub MidLine 1 sub div def
    /SaturationIncrement LastSaturation FirstSaturation sub MidLine 1 sub
                         div def
    /BrightnessIncrement LastBrightness FirstBrightness sub MidLine 1 sub
                         div def
    MidLine { GradientLoopHSB } repeat
  } if
  MidLine NumLines lt
  {
    /Hue LastHue def
    /Saturation LastSaturation def
    /Brightness LastBrightness def
    /HueIncrement FirstHue LastHue sub NumLines MidLine sub 1 sub div def
    /SaturationIncrement FirstSaturation LastSaturation sub
                         NumLines MidLine sub 1 sub div def
    /BrightnessIncrement FirstBrightness LastBrightness sub
                         NumLines MidLine sub 1 sub div def
    NumLines MidLine sub { GradientLoopHSB } repeat
  } if
} def
/GradientLoopHSB {
  0 CurrentY moveto
  x 0 rlineto
  0 YSizePerLine rlineto
  x neg 0 rlineto
  closepath
  Hue Saturation Brightness sethsbcolor fill
  /CurrentY CurrentY YSizePerLine add def
  /Brightness Brightness BrightnessIncrement add def
  /Saturation Saturation SaturationIncrement add def
  /Hue Hue HueIncrement add def
} def
%
end
%
% END pst-grad.pro

%%EndProcSet
%%BeginProcSet: 8r.enc 0 0
% File 8r.enc  TeX Base 1 Encoding  Revision 2.0  2002-10-30
%
% @@psencodingfile@{
%   author    = "S. Rahtz, P. MacKay, Alan Jeffrey, B. Horn, K. Berry,
%                W. Schmidt, P. Lehman",
%   version   = "2.0",
%   date      = "30 October 2002",
%   filename  = "8r.enc",
%   email     = "tex-fonts@@tug.org",
%   docstring = "This is the encoding vector for Type1 and TrueType
%                fonts to be used with TeX.  This file is part of the
%                PSNFSS bundle, version 9"
% @}
% 
% The idea is to have all the characters normally included in Type 1 fonts
% available for typesetting. This is effectively the characters in Adobe
% Standard encoding, ISO Latin 1, Windows ANSI including the euro symbol,
% MacRoman, and some extra characters from Lucida.
% 
% Character code assignments were made as follows:
% 
% (1) the Windows ANSI characters are almost all in their Windows ANSI
% positions, because some Windows users cannot easily reencode the
% fonts, and it makes no difference on other systems. The only Windows
% ANSI characters not available are those that make no sense for
% typesetting -- rubout (127 decimal), nobreakspace (160), softhyphen
% (173). quotesingle and grave are moved just because it's such an
% irritation not having them in TeX positions.
% 
% (2) Remaining characters are assigned arbitrarily to the lower part
% of the range, avoiding 0, 10 and 13 in case we meet dumb software.
% 
% (3) Y&Y Lucida Bright includes some extra text characters; in the
% hopes that other PostScript fonts, perhaps created for public
% consumption, will include them, they are included starting at 0x12.
% These are /dotlessj /ff /ffi /ffl.
% 
% (4) hyphen appears twice for compatibility with both ASCII and Windows.
%
% (5) /Euro was assigned to 128, as in Windows ANSI
%
% (6) Missing characters from MacRoman encoding incorporated as follows:
%
%     PostScript      MacRoman        TeXBase1
%     --------------  --------------  --------------
%     /notequal       173             0x16
%     /infinity       176             0x17
%     /lessequal      178             0x18
%     /greaterequal   179             0x19
%     /partialdiff    182             0x1A
%     /summation      183             0x1B
%     /product        184             0x1C
%     /pi             185             0x1D
%     /integral       186             0x81
%     /Omega          189             0x8D
%     /radical        195             0x8E
%     /approxequal    197             0x8F
%     /Delta          198             0x9D
%     /lozenge        215             0x9E
%
/TeXBase1Encoding [
% 0x00
 /.notdef /dotaccent /fi /fl
 /fraction /hungarumlaut /Lslash /lslash
 /ogonek /ring /.notdef /breve
 /minus /.notdef /Zcaron /zcaron
% 0x10
 /caron /dotlessi /dotlessj /ff
 /ffi /ffl /notequal /infinity
 /lessequal /greaterequal /partialdiff /summation
 /product /pi /grave /quotesingle
% 0x20
 /space /exclam /quotedbl /numbersign
 /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus
 /comma /hyphen /period /slash
% 0x30
 /zero /one /two /three
 /four /five /six /seven
 /eight /nine /colon /semicolon
 /less /equal /greater /question
% 0x40
 /at /A /B /C
 /D /E /F /G
 /H /I /J /K
 /L /M /N /O
% 0x50
 /P /Q /R /S
 /T /U /V /W
 /X /Y /Z /bracketleft
 /backslash /bracketright /asciicircum /underscore
% 0x60
 /quoteleft /a /b /c
 /d /e /f /g
 /h /i /j /k
 /l /m /n /o
% 0x70
 /p /q /r /s
 /t /u /v /w
 /x /y /z /braceleft
 /bar /braceright /asciitilde /.notdef
% 0x80
 /Euro /integral /quotesinglbase /florin
 /quotedblbase /ellipsis /dagger /daggerdbl
 /circumflex /perthousand /Scaron /guilsinglleft
 /OE /Omega /radical /approxequal
% 0x90
 /.notdef /.notdef /.notdef /quotedblleft
 /quotedblright /bullet /endash /emdash
 /tilde /trademark /scaron /guilsinglright
 /oe /Delta /lozenge /Ydieresis
% 0xA0
 /.notdef /exclamdown /cent /sterling
 /currency /yen /brokenbar /section
 /dieresis /copyright /ordfeminine /guillemotleft
 /logicalnot /hyphen /registered /macron
% 0xD0
 /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered
 /cedilla /onesuperior /ordmasculine /guillemotright
 /onequarter /onehalf /threequarters /questiondown
% 0xC0
 /Agrave /Aacute /Acircumflex /Atilde
 /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis
 /Igrave /Iacute /Icircumflex /Idieresis
% 0xD0
 /Eth /Ntilde /Ograve /Oacute
 /Ocircumflex /Otilde /Odieresis /multiply
 /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls
% 0xE0
 /agrave /aacute /acircumflex /atilde
 /adieresis /aring /ae /ccedilla
 /egrave /eacute /ecircumflex /edieresis
 /igrave /iacute /icircumflex /idieresis
% 0xF0
 /eth /ntilde /ograve /oacute
 /ocircumflex /otilde /odieresis /divide
 /oslash /ugrave /uacute /ucircumflex
 /udieresis /yacute /thorn /ydieresis
] def


%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]/Metrics
exch def dict begin Encoding{exch dup type/integertype ne{pop pop 1 sub
dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get div def}
ifelse}forall Metrics/Metrics currentdict end def[2 index currentdict
end definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{
dup sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1
roll mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def
dup[exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}
if}forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}
def end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/copypage{}N/p 3 def @MacSetUp}N/doclip{
psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll newpath 4 copy 4 2
roll moveto 6 -1 roll S lineto S lineto S lineto closepath clip newpath
moveto}N/endTexFig{end psf$SavedState restore}N/@beginspecial{SDict
begin/SpecialSave save N gsave normalscale currentpoint TR
@SpecialDefaults count/ocount X/dcount countdictstack N}N/@setspecial{
CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs neg 0 rlineto
closepath clip}if ho vo TR hsc vsc scale ang rotate rwiSeen{rwi urx llx
sub div rhiSeen{rhi ury lly sub div}{dup}ifelse scale llx neg lly neg TR
}{rhiSeen{rhi ury lly sub div dup scale llx neg lly neg TR}if}ifelse
CLIP 2 eq{newpath llx lly moveto urx lly lineto urx ury lineto llx ury
lineto closepath clip}if/showpage{}N/erasepage{}N/copypage{}N newpath}N
/@endspecial{count ocount sub{pop}repeat countdictstack dcount sub{end}
repeat grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: NimbusRomNo9L-Regu
%!PS-AdobeFont-1.0: NimbusRomNo9L-Regu 1.05
%%CreationDate: Wed Dec 22 1999
% Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development
% (URW)++,Copyright 1999 by (URW)++ Design & Development
% See the file COPYING (GNU General Public License) for license conditions.
% As a special exception, permission is granted to include this font
% program in a Postscript or PDF file that consists of a document that
% contains text to be displayed or printed using this font, regardless
% of the conditions or license applying to the document itself.
12 dict begin
/FontInfo 10 dict dup begin
/version (1.05) readonly def
/Notice ((URW)++,Copyright 1999 by (URW)++ Design & Development. See the file COPYING (GNU General Public License) for license conditions. As a special exception, permission is granted to include this font program in a Postscript or PDF file that consists of a document that contains text to be displayed or printed using this font, regardless of the conditions or license applying to the document itself.) readonly def
/Copyright (Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development) readonly def
/FullName (Nimbus Roman No9 L Regular) readonly def
/FamilyName (Nimbus Roman No9 L) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0.0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /NimbusRomNo9L-Regu def
/PaintType 0 def
/WMode 0 def
/FontBBox {-168 -281 1000 924} readonly def
/FontType 1 def
/FontMatrix [0.001 0.0 0.0 0.001 0.0 0.0] readonly def
/Encoding StandardEncoding def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC2C03103C68570A7B354A4A280AE
6FBF7F9888E039AB60FCAF852EB4CE3AFEB979D5EA70FDE44A2AE5C8C0166C27
BF9665EEA11C7D2329C1A211DD26BB372BE5822F5EA70D99EB578C7BEFD44CDF
045A363056E5E1CC51525EA6FC061DCEBB337208EFF729802376A2801424F670
0E7E6397B28F15BC10B40012B0A3EAEB2693E8F7F627C4C9C7C6C5BFF105C1E4
1B2B9E8F09253B76040D268B80719E1B3F5A55AB7B8E152A40E590419249F2E4
C36159F8E54B532468E36965A38646781AB0B7F6A3E851FD10CAA49ADFC1E546
2FD2EC6150DC6E19523050F6148348A561AD8D2E2721EFF8A570CB33460A745B
926C889304C09753C2D78FB0CA95DC6DE5B8C524752C83601E7E9F73DF660674
F05AD83A166DA9BE89F22FEABD4B2665960F6FB5BC32928E1230C212E5D69CEE
0B3311A1738A11747AE263106916D8E95F25B25B4BC6AFB03B79ABB95DDA518B
41A49458111D2A1433C043627EF9460D324FFE22935F4F6DA88B8B91AE95B34E
08408A34EC8EAC3F65B6AE3E3E2524867EE9D29068F81E4372F4470BEEB4D6BE
EE4DF956BECC0CB77F8490117B22B2FB75C938ED0A5E208D88BC38B2AB8B9CFB
F1D53084B6F43DF336481ECA0AA2D5317BC83FC0E1D4DB01D0B7707EEF217E94
A7F985102DED27D8E8B009F7EF6DB91B91E78BFAE7BD688E10B3DC9AC77CDEE8
47AA4DC8EC78241E593D26EC7A60696151A2AE5325D736E99E01BDCBDE69579F
92EEEC224B6757EEDC64A75455BB665DF42A0E4CE7B99BF3E7D66F8FFC8C13F9
D7A1FF7A9D5FF7AC43396779F11C9B008C33A2043D48B61B88B03104B1425F09
675B559CA4302C001EE80D2B739CC0FD1023BF4F1FF9C01E892E59CCA7C26011
B8E0B6D29CC29FC72792FDA5E7D5D88EF98F9DBA960C96534C399C54865EAB86
0FA2E0D6C7C44B553EAC1574D55E7970744D4792FFFBDCE6FB4365BDBC2965BB
2E9EDAD9E0EBF0B620DB415AD98297F5AE83D9C710436657E74D26E83957C745
89834337035A7501803947F6880B70E56A3A404C62D57B849D28804CBE0F5884
435A0E12DCC9BA414ABB732BFBAE237001F557DEA5E972BA0838A3C7C9EB75AA
4A050DA0A529BDFFBF9011C360564FD17A02C18860AF6B86EFD4E2C125686C9A
5E114E95C71FC89A5DE9C589BFE5AC0480CFF716345265D2435EDAE67CFC4801
5BC08E7A48D683ACDB91E05F469C0C8919D73A5D07A1CCB173E30E76680ACB09
02A40A3E11916198BD69F1A26E88330F50692D0D5917E99E7A01B327413E24AA
E98EA484E45897E6AE4D6997B6E8BBF61C9406E916D56985CB2BD297E8ACFC6E
CF2D2281AD84696B7C6CB584BD85CC20BA14ADD3BC3E25DB91124C0ACF22E902
3CFBF04CC40DE331991E9075D22AB5EE0E849B340050E6C417C664A782D05549
DB2EF572F193B1C12B4635C2B358747046DE585DE98B96A3F7E36CB37CE1EB1D
11E2CBF99F15F7C116DB632EB22A6C7A3C921FF716E9753F4068CD684517F327
58E8F5D1A42D40CCFB40C13249D90B00E1FB1F743CA143C191A39BA398B920B5
F25683596AADC66BF831DB6A5435937A0B37B5F1BC381AE33AB09D8ABD419796
3F247467259BADF061BF5F70E4BA0CD7D2227F5E20A5428CD87225C7FF28FDCD
4FB898A052A0B1A17FE1A99D03F851BF811AAE848B8F7F77D5075DEAF483E279
574CA2D0D685C7D7F56248A987EE709782646D145FCBC3309933A1310FD71115
A0B725E3EFD5C01936F03C32E26E9752568586AF8F68C03A0B150E234D3A5C32
A6EC201192FFD8BEC784F4132DEAEA3D477C0433ADAD9AA04C4B6A9E56344507
DFC06A839C74458AFE461803EDAAD78BF5F7A738766E78C1AD7686A3C54532B0
7F8856E3D629286E320BE4C2E6FCB731F6D39DA40442E648D10AADA23516331D
6E99469582FAC2901B629CE4137326A88F6E1DEC663321202D699E63A013EBB1
69289FB9333B6AEBEE1DE23F9179E939E8E50F7BE4118ECC2CC40F691AE9748D
2DD76D9D1546488B7E05ABAA458C5CE797A327685A564C11295A73FE3649A983
08BC5906C1DA356869FEA0B72C4FBCB931F9ADB92E0D1754C712F72AE86BB3D2
37159A840CCDDEA5AC5DF7A1CA1DD80CDDDAE0FBAB39361975EE9853129E4110
B676D6F655096130B2AFA9482F6006794C8902C6C1FBA20DA71AFBD8FF43B726
6414BBE146EBABA64AA813A47FAE8372C5528FD147FC39FBCE99CD1E5FFD007D
B0131D0FDB513D4F280E0FEE768A8A92CD12A452166A5C9ABE71B74569E1DD41
B82D849411C90C3CB8F91D3597D2B5C1C34689162EB4A741E46AD71C3E2F92EF
983C0CFF990C42264F805E66A8DBC8B1F083FC5F6136CAC7B79F5748CF681765
B54067A2EDE238F6657249CF57E563E6D290FB40D1348765A8481D1DE469E481
EEB8F8A422F2E0E9E655DFD6417DC8BC95BCDC6E60DEC83B2C8975577276FD8D
BDDE1366876EBCC64A3ABDC7D1A6C11C80CF098B6FF03D1FE08EF9370637DD9A
5DD48D0CC8F071BEF9B8173A6C4E227ED095BBA95B3DE028283DAAFF83008ED4
B19CAE27A55405DE1BC5680EEE1C7884E863992976D32D5EAFCE214A74C5731D
3162480D9F316B578CEE6BC5A4565BA159DFFDB5B99A76D4B0C9C7546F8F7336
8C496DF7CB909D84EF2D9C7E8BE72A74782342D4DDC371E175F725009AFAFAF8
DD4279E8708996E4389AB381E3DD97E48D7EE0788E7466F23FDFA93E8C92F737
3E2BB9135BDD22B310B27E0997BFBA4127C5BDDDF607955F3A380A930723612B
3CF35553144F4004694D39E05F5E2A6E7774DDE8EB438A8D050EAFB3BD19017B
F75A3A544D9B4E4A3C202A37840975CA6BC6EDED9B841D36838D978E70B55AA8
A5944B25A9E343F133B45B1FA3F8069E8F86C27B9FFB476B565EC112214654F3
25E4B2C26CA4C437723D419493636619A8DABFB3023F9D723E188D5A88F90629
41187F24FB1AF13A4BDDD62CA03C671AD7C832FEEC5C3A344C66DB32B499D1CA
815A9ADA4646460957FDFA79D9560CB15AE9E1CBAA458F83DB9A134B62690132
914F2A749AC66239014F3021C2A8F7B4A73F0204CBD6CA0F618A63DBD2B69BE0
D1124BDF8EFE3FF6FF5A943CEED8C1F02C650105E8092702D8DA1BE48FC44AC5
5C1C1B6916E2ABF5B2EC4E5F9957BBDFF06EFF38D2448F6E23E0B550CABBCA69
BBD062515E16F653C7F38A2A82E37995CADF70334FF6D7B4C6A21FE17FF03642
DDC2431E1547205847E9538056D89BCB048910F3D70211E5836DDD1A9FD42E78
3B3383D3CE0A656E28BAB9D09104B436C27F4AA0CA26ADD8973581F868E68C30
BBBC8AF0FEB7C4BE01C5454E0321DFE5E9F22D72CF86CE1AC14C47273C857025
C0DF9CDA39BEE3B790E1D778EA2294E84A32791E5E96831842E64896CC6DEA0F
7E3AF4C39EE4E68AA31889A377F9775BEE16B10B7FB0291B68BBC5DD2C7A5ACB
4110BD0288B81EE909C1C6481A61401BD72C146D133AB4F450631E86379F959C
BD9EC46414A822A022439DD5E7CAA8B511A630E8148A51C1394C7C321156CF52
EBEB7EE665F4E74227B5A328BE08D81F6EB1A4EF484E02287D645472E49931F5
C4CFDB323DBD67682CA8BDEF987D5C3329FCBFD894D1F2FE8AD1BBC6A27EB820
16CD87A1A38A0CCAB4AFFB3159A66A113E066238B6C607261AFC2B0A6F5BDF6C
C77C8E43C053205C11168ADF69931B83B3329DDDD044BD3C3C36FABC9898C446
3173D9F296B3DD186F8C3F8658C91B59C58B51B539DCB6B3E5B2E3A3F114CD15
1B2B93F439EF6E900E1F6795BEDABC7C47532B4B80F77BF6EE43CFD08C913100
867E2028EE56949E915B81C56CD5055CD7F524DB63430063A0E77220CED0EF8D
A2C258BB069706DBAD9336BC2301C2B38FD9308BDC1A1B3482A99DC9094AEDB5
C9B0DC109B02A806265BCC947E00760E7F2F33158E7065B09977A242A2F63B5B
A9987C43E34B7A21AA0B0A6C08C22B1A0F06F62B4F70F5A3EC389BD83EE4E883
5DD02346B30E960A439F315CC046A71DD75AA66DC74A32EE10819388782A2B18
3A21A666523FB8F1BD0C4E0EDDB5331F46BEB8ED9B6BB6BFADCEDA16D910EF05
6A6CAC6E483F0EA9BC2BB7783E87F3232DCCA395E47DBA48DACC997B35054F37
5121368C84E6BB7A19CE1D585BB1A4E1C6962D5D027869BFA0DD1DC0D6A09453
6A454CDCC002CCEAC47C312E844D1FF90FB85E543552E478783F020F6F43D854
DFCC2944ACDE5F3989C590C6DAE815B4B6D63CD9F8C4F2EA357D408C989F825C
8CA0B597B53C77DDB76BFB9A3507D0E4834581DAD05E1805FF9C7738616F2316
393072FA1BE37D2DBD8C1140496DF87404EC95C6B5ABDF31BF44FC857A277466
E6C82D606AB2BCD7AB93A8795AA46773CFDEA403758846C984CDAEDA86706DAB
4E6ECFCB1D91887A61CE4382705468F167630971BC01DC641766DC254D9E9F4D
1718D13CF485B3CAE0E01B327EE29107319D27F5E928B6D1B65C089468A339B8
FA87B88CF526AB2A3C97ECE5E198A6C53257207EF1D6DF448C97CD7C7C99D27D
23E3E543B75A97A7BC960A7F742A2C8921283615593D8013072D6BCF9777D2D3
E87F6F5E3C48CBEE68DD8305909CA8A1E6B1B85051F411A44C4875F78D630234
115C10B5CDC5920699437B7A1A31096F34145715A88FAB1C999BD8C391F4F045
EE1155E8E993334DE7764362A220AAA68E2CEEE203C7902489D4F4C054B81D6C
955061B4CF384887BA2A9A504B2A0A92D20AA3993ACBE8F75502C3D655D9F129
8C77D8C644FFD2DB369626DB03244237C980DFECC233D463546CFE9004CB5163
EF7FF065FE895D0F59D9E57DC8F688D72036CC3306C5A6A7F2921367D2498DA3
D214AE275FEEB988E443D762F78EB550A53730ED711AA6107DA96A48218F0C83
3D2145FE98DB194436D680F2CFE4776A547FF4F5B4D93180F66A13E8617AF5AF
48722C05644840865A68BAAD309AF10CBDC45F31E98336D9D7487F89A92B89B8
917307766C4D22819784EADE3DB6C90FAF9F9F684D927C597918F2DDE45FE044
2D2E487C9425C514D4535553556FB890BC01144001329CB38264B2914596521B
89D35C673FA2228E90AC382E0D9C154FFA8AEECA3F9C4A18D9B9FE0B317BE163
25D99F92D1A862DF1892A0444B7171892236458DB270045159E78080E96F5F6C
C6C1072FCF2B9A73737C6E09CF8C00CC2142A384B646F36CE1CBCBC01D979F0E
190327F0E0835495E3E7326BBC920AA3F90F92E15B9020F1BA6F561D9230A457
7E42C007755667CCD4B2F0701EF92FA6836C2CCA2FF56C8B653443061FD65C06
7C68A45FDED7BB033881464DFD5C4A6181C0F7CD50AA63590382B9C477BDA86A
810034E16CC0C876B0D072EABAB7E3AD87FADDB367620BC0E94534D0AC7160F0
0F0A99785887578A5DAC624EFFE6B11B08279612CF5CC5768C0AB33347CC23E8
3D19A5833FA58999C33467C7F49C3ADC92128C47321C2C2E906A9D15AFBCE614
8ECE990082E5A4B83116D297C76EAF72B27279036B72C900F6DCE1C04FAA4D89
3D3A4F5A15AF3E1BD133241D58DDCC67037061D45335253B2F21D7082423D46E
B801F8502449684418493C3E0A8E0F1525CEB017B47C1D4042C85EEFEC49D94E
6CE893F31E2C049463AE81F753E2F863AAF5E28673190E4A4B508A313AB9EB6E
4911FC465A7F3884C477F6A436B2F6C54C1ABE7AD98C4BFF998A9E337BD16D60
0CC326634F3D05C8F61EE2068824B4AAE5F3D674ADA40074AF023B6737631A91
A605447FC44BDB516C6C251ABC1D6A10EAC63EA4B4E55BAA92BE152FE8233BB4
A00E6573D5CE090C2DBDCA93B57A82AF52A14DB5E2FB6D58CB1599834A73F6A7
F1957BF95A52353BFF9D377CC8B947BB87F744D96549B1599480FD287DB8D742
D6A9D603AB2DBCD015EC7380AAEA0E342F54E13C3F48838F6B8EF1CEF30330B0
AC6E3AAF2D093E7B9959317CEC74A3987C2ED552B37D806B0D6C19A76E499F71
9764BA6BA81E4CC3EDE69662E43363AF2896F9CD9A245C72A9686348748A6DD1
FC2C50736413B5CC41E846CE386666CE987B339C6C92780E461F9A6E0C1DB6EC
3C858BF115A7704F38678AAC212F3A4F89ABBC4B401D09AEC90E71132EABB053
9A64768B17FECFA7C2E70A4086F25183DAA9D8861E0A486F9F9874A71B79F606
3FF117C9767B7B363872C1A60161C3A8E8D927ECD3B5E0B8DF27AB8BF1EF4C60
867B9FD954F501CACC60909404D7B6FAAEC915380A230FCDEDD11FBA0EB4B500
D2A267F9221010652773BF2BAC1EC005AFF5D7024A8C05080729302F93648963
049B1C0AF67FE312C7299F031858185B21E923D04C858F767678E6FC5C937094
F4D51D4B2F8244522A79CEE7C15D6C306375EE968096691E2010854BE9B09612
9979E7DA5107991A084DCA2A5A199CB883B664CF8799E2505AC7F189FB243A03
528359F9CA0BC7FD7E77265441DBB89C98134AB1E16C506CF003828E7F53B24E
0968A755A2475F529B4690D1DD6A791071EBC06C48854805AC61CE3504D38570
90595911A900FED40C0AAF0832D0A23A3CAE652858ACFEDF2C5190B9E7414CC4
05472104DA8E756FB14F474499E963AF1569A5323997D5F07CD2B74149A7B4D7
D2451101D1F8D5B01E4BCE2943D6A9206B2BC5764880798290356E1397266A26
FC9BC550CAC877F37650962F08BADBF5E1072D4D4BC92EE094E86464719934B4
342C86ED7BAAA66B457B4C3531408FD03CCE480B3B8111851050489E0700AC9F
FC2A975824CE6229C1AC28ADBFE18C64511AE8C6F134097EF0CE798DC546A507
95F07053E8CACEEE3E3153FCAB30E97425CD22CC968798E19CF47F6505B23F04
72D19A410777F87B7FD2D047D6A908E556CDF68F66462FABDDBE2B6BA6094E6C
918E64B281D238244C362AE460859D2A8E7C7BF3CF86F05DC1C8416B6F610B06
282B05398BFFA7E86202BC278D61F86DEF8D616B1EA4A3E9B18043320B82309C
8A094A7CF9B98E975EF233F3DEA141194DFFEAF3E73DED59558A1A5587AF1643
5837880EB6CACA758F6F455560B34624A6EA3B027A031DBB1C223C370246D602
2ECF0A1AEF94869300EDA17B6652F8DEFC2D91D24026D45ED9C1B07FF10D566D
6E23C26F757696C3F13155A0C3E6EDA91ECFEC0ECF0B5340E0DDD17A6381B58D
B316C7F2D238B7EDA1CA4AD405276E3513DB07C21862F809AE2F233B284EBB60
B62D8A138CAB931B81EA650400231127AADAD2B7F770C903FC6FC11AFBF5E115
CA702042CE6FEE1F21EFD4C2523815316CCEC39102C56B0C34A6D702EC60EB65
4AF7FAF2E7B248E9DC4B1B14F778593348CE9D0594CE0EB8A48789EE488E0B62
49E0B7238A78A14E4A422D0CDC0F0D90E754649F5798800A197A853688E3AAB1
D25BEC71215D5FD7221A02CDFEE6D0541AC711EC68B79C2FCE43166206395BB9
C8ECAE54B1CD73F649045926690354E50BC40EEC2E7028D069897328EB2AFBA1
52541B746C17FD1C68EBD1BE93E5D104CFF70C3898E5A7AF6035742BB70ED772
AA06BD4975F4447847970A71E059C663B049AECAD616232E83260486DC257E6A
30D4CD3EE248CBE3085222A8A165FB9D0C92DE664B12204682BEDCBAF71B31D8
411FDE40C0465F28F0598DD5C4C2226E9CDC2C7B3F4693D296F9B6460DA885B6
11744B36A85B90D6850ED99F3D37DBFA2589CD40BD39B1216E0442F267E14F74
9D22713C371BDAB3F320DF0E58B87F3B3DF2BD602EB0916471AD99DB7AB4322E
EEDB919E048B825428B9A87CE293200AC41E47B1B478FE28C2CF995DC875B949
E8EC26D0D790FDBCEF4BF28DD94C99136295744B66327E4D7554E8CD52AD10B9
D4931D81DC972C25FAAE75293E3D0577ECD863026D8847FEBBEB405AA1E51C72
3A236AEDFF56763E249478FB173E7C34DCDC1A5F2A69FACFFCFBFE6EA76FEDCC
4FCFC3FE9E361882FB73321997E4E22D0193F9089EE326A34B3ACAACE95E4F1A
87A6F8EAB43381747320F947F786269FDE8CD4ACB9B9E7984F498439DC44FC4C
E0A4EF691E21A7F3B3BB04A6AC0249835F399A5539258C0C5787E665F691F0E1
1349817CFD5784B256FF54982A922AAB888219F6137AD44BEE81CB38E3B6C23A
7703A28BB9344120AEC80007EF80FF36A2002E68A7EC2AC678232F3887095E16
A928A6D2E5A759F586AD85B588A1954DCEA9BB8BF813CB9DB27C3EBB603F96E5
E51FCED193AE9EA20D0430AEF9BF9DFCB924722A186AD3695B4815384EFE204B
6EBD1E8AEAB43E845430086142AB3A0B154DE2B432A4EF54899AE2F667584F08
C11A6C3C15F5DC4598C89ED029CE5EB753F17171E032DA77303FD6C2DE0879D0
551EC0CD32BE876070D4FC798EB11DF323A276C67EC65A7C9AFEABFD6D8CD6DC
9D2068844DFE2CF1426111332164983D6145BBF6857ACA9D558F93BA20BE854B
54F0BF5B1A2F82730B52C668A8A779A3DA798BF78D2B13125623CD22526D2F3A
3ED43FF0A4FCB3B2F249201E0D5DCD70D140B498BA43863C45D94E6642DD04CB
DDE362640A289060DE4202AFF6751FB0E9271CAAD9E32CE79EEF40ED1A5A247F
A60A89A2EF6AB95CAE1FB11957D3D7CC7C04DCA33030F187E88F3A42403FD460
6197C604F2C5920C97B1584B7E0051107EE778B10EC2C521A354BA3CF445B08F
AC37BF352FB4A942CC07D024B75375EB6BA1E22403433D97EF143C518E3BE33F
0B75634EA9A4AE0FD8755324C32808C36F09348083188D680E46FA63C0F8349C
3AADF23AB9DC6889E4F30B6735762BC2F892D4F25525205CD1C2242E39B0DCA7
33B369EBFA1BABC1405AA368891731470E7FD95C16F4BEBDAA841F389C6BDE8D
3A9E7B11F6016684158051E54FB58AEAB76505D76C90642DCA431054E711E7B8
06E28F5292802E6BCE8C5B4270F6A9C9DC5FEA5E8AB1162FD4430CE759981E94
3CD7269DA857305D705D9CC59167FE6FACA535B9F7705FE731D2142235BA17FB
EF28E9CB45E9C5A9AA32B7ED753FA2F71B3242E99F29ABCB3D5EF43EF92AE42D
BB0EF47ECCB61A7B87B6520BE99C8CD93BF924DE2815332A8AEEC83E167D7BBF
2A83179001733CF30B5A2C9C37B15C605D5ED55E679EA19733AE4CE92272FE79
22D004F943A05ECD16CF26E00CD63CFD2ACD3852830444ACC1584CD63883F21F
0FF173A441E4EC7E279F1F1A11433EA8F4B0CA58DC0863F7C2FA68C4AEE32470
9BEB7F3564BF8FEF1FD7DC6C9CDA5B4D8A729A23225D2CF8E6EF2C568B3836FF
37E1C2BB3234B0AF1B5D6C0673CD53495F1B42D8CE72C2F4D71A5574750FECE6
4BB5006ABC9AEC870812A827AA8E36995855349B1E9A0B788E243492516DF5E5
6F9E573F42AADF489B54861563E77740D607218CCAE6B6671AA2C0E54865F368
D12BB1C155658BB6E3D64BED64FFDDC683B50F16A3AACED2042AFB7CB8885846
0346748DF6F2348D53974F36F0573D00544F9D7DE1DECD3B8983E560AE31E321
2BA1FE740C4A0A0C1EBADD3FA681B5D7FEFB9C0B2A3701FE54EFE72CD0D2BDB7
355B639AFAB6289F9A6370BAAD6305A2F219F872B1C0E9C465E94AAFAEEEC73F
2ADB8BC567224AAFCFD93D9095921AFCC55094503F982A14571F5345962DED3B
80B030109F9F176AC52DC8E4CCCB03F2BD47F24845E3FEE73C5C22474EEF2FF1
C792ABBE6E6025969A18A510A89F22FD0B3D25692D29586A6F1849E08A7E1B43
265201F14845448483F8EB9EF39C05098EE674166A70F04382E418BF35BF244F
DDD5558E5239D1C028E96A9769145B9F62CFDC3B79A0232EC6D0589CB018E506
F99E02BA065466CDB2C648779B57B698763CC188BCDC6C63AEFDA63F2EBB51C7
91B2F0C01E3CED180DA06394427D000D59A2C093BCBF95B3342044FBB92DE756
C0747CA26E829800CE4AAD98F6CBCDFBD90B69A6E2A3BEFF5427C034CF0128DF
47A8B3BE724F1886943A39661632CE15CAD67EA78AB7E80316B269223DAD3583
E44BEE398F16E09681886CD627610737CB42966EA3F5273CD816DEA7B21CFF20
F3379FB731A68582CF3075CA8C4CD8DE501AC55BE69F055B01E0833264D7D208
382839ADAC080E47FBD491626CA771E2B69CE5CAABAAD6CA7F4A0CF91F7087EE
721F64CA0E33B511878F1E0C86080C59532C46091584E9CF7759EF3E2FBBC0EE
740CD6BDD2ADD253FE74A224D2F07EB970C525B6BF8E81FB5B159D6979D86139
4B757231173420B130353EAC9DCA944F1B097EDD59B660C3B8991F7857064BC3
D189A1B8948521A54AA1B3BE277E804C6BA17F299172AC3A4A3FC57BE0FF455F
34F89764223F7DC55BA669B8793F48CA8C25306F365CAA3FBCFBDF6159181B48
799F6EB6B3CF2BDB3A9179E939E8E50F7BE4118ECC2CC40F691AE9748D222A15
E6B4BA25D13F5D195BFB749751279816BC7FD2E9453A1CD0068835D69B4651E2
06B397E2D6F3E1134835F691D7403FDE31BC694628B99661DF32F2D4BD16E7A0
9B7CB9524FBB56170E9ADEF02464A57D0CC0A7508050CD63E61EAE3FBA7645AB
573A5E5EBF40C14681BAD1AF87FE9F81D116EE6F2F9709188C1272EC7EC647C8
8B8678856706544C8441F843626D9DBBAFC2E2A6723A9B86752AF24A30A0F8AD
E2BA797FD81263D5825188777D21B8ADD5C2470207BED74E1D296DD7D44B615A
6CC13CA81763379F634CC44BC9F5F4CEFE3B4245E981074B8637A89EE47EAF9B
93FAE03951E92DFBFA783B47A38FD1B0ED7F6D53F76F3056CD14C2D98C3CD07C
942610177BA2E331993DF752B5FC60187926694EC48CB03CF1EACFD31FEE3C7A
FFFF0C5D570F6210060F6439E9CCA612DC7ACE7AD12F478F25D79F74564646B0
910BA9E173FD2222DDED8C4BB4813D923C851CF7D067CA7DE1A77CEF2637193B
C60FB9D2AB751DA74C0089676139B95B6170A1856367EE3FBBBB32173EF8436D
AB7E1F3B2B1417451DF6A798A1CDF1DD1BC631FDD0D434E7C0F668AF758C46B5
E53F46EF208122DB5C4FA68C4F8F52F0A87021F773E844F7E60E12E4EFF4A79D
6295CE18217C34587290413C870368709A54C7F54C093A2F8E5140B80AA51BBD
64DDC6324FD64B6A2AA81511DD7A32E45FAF5D1245117F52001F9FE45DC08D02
6D6D6CAB0A90A6891CC6A139CEBFDD92309A26A3C53B5CBE94FB5A471CDB84DA
45C5C669871A0D9D5ADC6457C13CFE68DE8799588F977458D0CE35E7D5460EF0
5BEAA75D80040DAAA0C69D2FD8738EC4426E569D2223C47281BA7C752A4F836D
CFEC10C2B121966B685911470D934940D502BB95B72C0691CBC7A62492AF05D3
E9D259B33AFDCF2DCE2783D4B1B9284D485DD40BCDFCBB490A40E49927CF4F1B
ED103FEFA84322FC61A52D6F66BE3CE1B4D0E03C1A537ED6B29FF9D2227A5447
F002948406AB0CE276CBA0CDC05E45D59FF354E4F8EF78E7E551F5BB6270E401
7237825DB5F7B38287124B1DF043B0FCB63601EB9C31FCC01FCDD51BD6740F4B
DE2445C5EFF77DC794BF3640745A0B2E51B1B7800EB1B22A54B24B3485E7266F
D9CC2D30C7486438C4EB99365D68F27B9FCC33D4A82035A3817493FFA2A96BE6
8470C00E75A37680D49F7894622E934429B55AE8A89CB8810005D43CEADAC961
2A2DF8A5ECA166A538F050AFEB5E0CAE47C3FBA61D0CE72227D6C03C5CCD46EA
AF3E000C9245F536030DE2F2AC2B228BFABE582621648F48CC413EDED067EF9B
EEEA11347881248B9EE4C311EF9941A1871225866E12E2B87190DE970CFA8C8D
76A53677E7150CB9A33D3DFF3946558639A51028FF0D3CDEE821F97213667089
9768880BA8941EC0D4197BFD15B110E435A6C93C4B9A984096130968AFB5284A
278F08FD450567FA38EF4A010479CF9C997DFB0204133EA171996E809A1F5BA1
0F35AD7BF4CCB7030608418B96A48D62B8189704DF4D12FB799212CD03A414E4
A3C6FCDF88DCBB094848B0FBBC59203B09119BD68A70CD223C46338276DE6E20
54F4C333CEECD0F9A64E63DB16FA988427F23CDA4BC3F9C018C3D8273DA93F0E
2928B5DB5CB962B638A8B4C0597214659F90FED46638FDA8BDD4DE1F8034C107
ED09FDE3E404320C22AC7F51E76C8B3F51F5F1C05B1237C7D00C92BBFFF382A2
B3A6BD0AFEF9400260B3EE7257D1D300AF9BC17825D628D107374AFED4DF32D6
91A6300E5FD62DC55EF67AC9D2542AB4A9C67F4235A69124CEC3A2F54A15B344
CD009F8647275F6DD6747C70F594AF631DAE6CEC6DED346B4555D1B10A1CAB6F
9CEE63AEDD180A2160EF9CA1374DF32331AE70A48FAD1138603558C92A384960
938C4DEAB066E8DA7B1655C682433CFF6659F802EE15C8E072817A4164085D1A
B8B163D1F45A732B3BC5041A19F6F16B9ACE8CB71457D877BD1C5EBEAB82E845
B1D823DD9AFFBDD1C2EC33D547A786C824114BD6BC71100645483453FBA17A3D
FA480AB99C40B2A835F6BBFECFEFFFADBDE6766297A9B786B0FE4B77BB3578A3
64FCF53535DD879D53C76043E1C7240382CB40E01E2035DB5791189643C02B06
2F2C5A27E5ACDE7E67F88B748BF7A7BFE64524976FD985CF3916589B63003837
39E8C720270E48176DFCF432EECFB56367576617D9E0CC574CF950C2AA5E3981
BC2C0884C2E06A9D9185EFA23D28220D01E01475A141EB86C79B4EAD4B2978D2
5E87BD9735A0A8003D3C3D229A1587B65F501E6C1F35E58AF6F1C2B2E934DF0E
FCB082396A17F08702A96DFB3AF89C01AD3A1DEB7241A6207C86C31DBFBF3167
D9AC4A08FD88BB5EBAD06949EA78D6F9DFDBD78A7A27EFC9C1D43EF4779C8F3A
9A89343A3AD1D0727DB11ED4015FCD48CDE2038138BD9B9156FC130A2C498635
C277D25627D342B234CEA5B546D74ABE95572AFB67D6374F1EF94B867485CF12
4644FBBD7694F663FE8BB340C0973082BC5C017AFBEDD12974D59F272739156F
3B8CA75B861ED6623E09786D92806223F93DE2990509E185383CC48930FCF960
EE62E049E6D910D6ECEE4BD506A3E6479C399487C2D43E834E4022BCBD553618
4E620C8C9F2834598E57A3FAEB445D2FFD49F02B58FFC76EFD5EBC55D0115CFE
562FE0F66A2B97F8DCD81A54FE70049D5A2D8F57623E5406012FE49BC84AE170
501815583E26928B37FAE2F539A94C3D1961BFB9E7B1BF0FC8CCD39B564A2EC9
72BCF2D0AF2C8C22A6B3417D9EB1970730020F5E3066ECED25F063FB86848A66
FB6506175D55616B3BA66F62D949145415723ED0B64CEC33739E4A348105BFDF
DC56E7ACB7D7C4AED9CFE5A20691DAD1F2D9DBE606D6BDE572AC0D0848EFE8FA
8DF2C2124AB1C6BD2EB032F8905EDB5E140B28CD68DA32103588F0B782EAD5F4
7E04637E3CF3293554C1B91B94CDB903499F9CDC9A99A9AB68B1DF7FFFED7F9D
D2068E377284A963AFF0B15C403BB84A6114762A1CB6478A4804C415FD62E413
7FD2F89FB2B7A29CABD484707DCB19E04A8CBDC82A51AE32A48F379B108D319A
58AEBFBF729A8D1A32759103FE828F04C2C433B8981E13BDA764C03EF4A05542
11836F8A2CED895655AF1A57FCE55FEA99BF4EDB869CFA2309644D4E4D0E2334
6FDF311B1D97365E534349AC7B0365B6E5F6ECECC409F2B46D90EC4B61088F01
8F04EED5ED14A2646BAFCBF1A68342DF56D1B593A0D78920AC2D457EC06AF41B
9FD7A3F09E55607E5FFBF11245ED71186B92D061581BB54CD4D1AA2CFB93414B
24F256A1D98E842691F86E72B19431D223A91A20BC547689AB6048594859B08E
A7984B4BD1211EFAB8C334C86689D3A7A6849F3ED7E032E46C49208D0B839FCF
BA1502696A2FC6C88A359B7A927FE2793015539A74057DFEA96CAFE71279B240
CFB536279AD263819CC606953F931897097E36543C688FFF5FF01D168065F6A5
7FB7FD5EA3270BD689C86C54D74B1E052534C6F2F60E9A8A2F131AB5AAB62C3B
7765CC804076A4EB1810E39E926952CB40EBCFAE223D7931AA69366752A4632A
5D569BFAB788F14B2D512EB50D71B3E67DABA26B6289A8460F85EF456077927D
B2C41A29B2883690E7A1023B879B09C2DDDA091EE064E11019726B959174F50C
8D3A1FA9C924E8517AEC11412BF9013A976FDD4560799B367A128A9AA2234765
40D694A201A0E3310D8BB09ABAEA5D0D0404C1F29E84588BD9E4D9567CD59E39
2D0662BFBCA7ED70EB1C638F8927393EB579F2AF8A8CABB6DE43F19A596141EF
3DF851A836412D9095CE5CF8F5B1D84F9897308DE9A839EE77B85CA7107519E0
52AB6DF6CA6717D3F6300039D6155BDE1698249D3432CE3327503EC92D97DE08
2183D51A95456AED79275106856F5A126D12CA19AB44502BA3C54126F6CC13C7
BC985CDE0F1777A13262E81CA88E64E9EE09171E9761BC1E4B60224B331F5026
72B17951401ECC2A02F05E1BF6FEAB4E6D90893ED8B7D52CE372F0415581AF58
4E040F89694EE10B258C45663B4E24D998BE7B76D11B0BD2B7F31DFB1C68B265
5D7841443F4173CE0FEABDB3B1202EBC1AA0D28C4B9E051603E2EF5EAE91EE18
02BEC440F675118D8DEBACD7FC60FB9457CAC27EC5ECEA58902537ED713B68B1
7E4C350E4E000E8BFAE89A5D83095F15664D8DADB9EA0FB0E2FD6C91FDD0EAF3
924313B7262840C5CD7CCD1363FB1EED02298CC8F583AB7B2FDC65A57BCC4D97
3B036EA5FF446BB0B8704B035E0F12D0BD658BBB36E97B99F67B5FD4170BECAC
566DF798F2BB0FD285325C235859A4C0895A61829FF8222A8B780BA4A29B5BA7
F265981C62E866090A775302655FC84C9C67A24B407BBBA69F175F3DD0B36D7E
31D492FB56AA1E63D9C1B2025FC6B1F416E2A00BC4F5B0D4EA09BA228586E8B8
1DC4B2DD431DCF2E72962BD317C74AD90A0BBF95A37B8B566414FC96EF5CEC57
F87401017F404527A54237C763456320B0BBC46FCCFC4AE4B1E107EDB25797A5
AB0739ACE25C6CCD57B58B8FB4AD2FE952D7B25E3C834F74628BA7CC8C343AA3
9B0516B5C7E7BF706E15BF748A7A96089D36A63ACF0454CDEC904F97CC2D9D03
D084FD7E50C5BAE6E7D24C6911BB8603519F7040F0B09DFB0AE4EFA21472DBEE
58CE864AB02D0C87A989676670E8BB1C049FEE7AE80AA3D7CB1754D5B0ACD523
89BD79FC133F13A30A11C9EB7BC0C1BE7547A55FDEE3C7C4F5B1EF70778B242B
67CBA3DD5DFB4574F1CF33E029AF69080604341BA7D907287DF333D8EF6EDFCD
D09DDDB827C20F3C63E0D052CF54C27410BDC4BA4B1C01A2CE1F7B9FD3B35074
24F2945AC55D0479A3DE81C68B9F12EC3AF3361A716E1410C8B51174342A04E8
F760B1F9B85CC355A3C9B66621B1B9F23879AAF5F2F626B39C00D71FD8FC893A
718A6A9808B3AD28B51793C9C706FA8C45492AEDF1AC7373714DEF72BDA47156
F1B973F8237718D341968C217A3E62CB8519FFFBC2FC0E27DD9837F512DD5085
7FA6BAA8932D841D2B9EDA4FEA4CDC29BF9B6118B1AFE89F1F0045EFF7FB0B2D
1AB726E39B0DE0676FB307A5A88D366CD8D65B7DFAD93F19D52DCB73E4379C6E
72EBC8C389D9C4B773124BEFF75D0DB48DC09A4042140A9DDD953DFD01CAEB18
04438850C5D7AD25256876FAA1CA9C62FB05712F93CA9DB7A297E241DEA8CEB6
F43C5B08BBF65F2E90E6DFD337DFDD37DE8FBE61FDDDC60B5DF6AF540EB2DEB6
8A663DC567244177DE1BFA519D1EEA4454D5F726999860673D8A212C82FE87F6
F666CADEDF43E9A86D13C180C4845E8F762C9AA0DA4155FAE9E63EFE078C8EF9
FF1E3C38483CFCB8A67D00A069DD835C575256F0C611ED3ABAE1BFCDBD977F99
3ADC06F4D32E3E911EF18186172CA48BF3AFC54F51F174CC279067E22B1F7211
4F2C9EE57E2B31DD74CBD40A135BC54B948F3CCBC424476F4856CD3C84435C06
2B8AF4FD2C50D52A57EDBDF386E03BA98EADDEE06798B42CBE7D94679EDCD00E
08EB1C200E05E6EC6F15E7F3F48B411AB82EB68722B2A77209B8BEBA80270404
48B2934FB6970C30A73D8F1D3A7A87315B12D582ADCF15F448DF4B8C33F95133
1642B78C7D32F8B8E53DEBC7908F1EADE4ACD98A47E3F5E6D9B4DE5447E2478F
0CCBA2E41633D783BB502EDB866BFB7889627C476982112F189671BB229450BC
0F5FB4B26791B7F1115E2C37AF0835AB37C02E120339A146B806ADCB06041EBD
922C18D4011C4A479F34D0576A220B4E59C46B38277A50663441AE2F5EE9C493
CA6A8152A31181D20909D6EBE7EAEC9FBB6904578B9804AC52B8EF5AC39B2597
DACFBD9441C4C2FDE001AE4BEA1154F89A82DC29FD6B6EE811F1CEFCEB335C39
EF2AE3
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: NimbusRomNo9L-Medi
%!PS-AdobeFont-1.0: NimbusRomNo9L-Medi 1.05
%%CreationDate: Wed Dec 22 1999
% Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development
% (URW)++,Copyright 1999 by (URW)++ Design & Development
% See the file COPYING (GNU General Public License) for license conditions.
% As a special exception, permission is granted to include this font
% program in a Postscript or PDF file that consists of a document that
% contains text to be displayed or printed using this font, regardless
% of the conditions or license applying to the document itself.
12 dict begin
/FontInfo 10 dict dup begin
/version (1.05) readonly def
/Notice ((URW)++,Copyright 1999 by (URW)++ Design & Development. See the file COPYING (GNU General Public License) for license conditions. As a special exception, permission is granted to include this font program in a Postscript or PDF file that consists of a document that contains text to be displayed or printed using this font, regardless of the conditions or license applying to the document itself.) readonly def
/Copyright (Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development) readonly def
/FullName (Nimbus Roman No9 L Medium) readonly def
/FamilyName (Nimbus Roman No9 L) readonly def
/Weight (Bold) readonly def
/ItalicAngle 0.0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /NimbusRomNo9L-Medi def
/PaintType 0 def
/WMode 0 def
/FontBBox {-168 -341 1000 960} readonly def
/FontType 1 def
/FontMatrix [0.001 0.0 0.0 0.001 0.0 0.0] readonly def
/Encoding StandardEncoding def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC2C03103C68570A7B354A4A280AE
6FBF7F9888E039AB60FCAF852EB4CE3AFEB979D5EA70FDE44A2AE5C8C0166C27
BF9665EEA11C7D2329C1A211DD26BB372BE5822F5EA70D99EB578C7BEFD44CDF
045A363056E5E1CC51525EA6FC061DCEBB337208EFF729802376A2801424F670
0E7E6397B28F15BC10B40012B0A3EAEB2693E8F7F627C4C9C7C6C5BFF105C1E4
1B2B9E8F09253B76040D268B80719E1B3F5A55AB7B8E178732AD0E135F772215
EA7EB7EA7641D31502E1BB9661E7B0E875AEE90400138F2AAF4A8686C73EAA44
E5CAB467770A3D12E9807BAC97B24A8EFB0E276760F4F51EC7123C43BC6F8DCF
9A2F496A9172813FB461FD870763306B45670653A9780FF409B734CFA74C12CD
150B03344295918C4ED893FB620A9499404B83C71152BF2F2DBF769000D116D5
EE264C016EE3E1241018F59544CCE53E5AEC124CF6C59A4D7D7D511ECC9AFD49
6608ADDD237358D7CF8B4D1C5BD1158CDF2D6469D9BD6E6D9762ECF34D1C3C27
5F69900E0D12AF9B21F153585742E999870BEE3DFF6309CD82968EBB40D9C269
CD4306654AAB6734151132DE4194072485FD082FBB6DFCB3FDFF9E1FC88D9483
8AA64B5825293978C70C9EC095B18352BFDC34B4BE9C939384E3281BCC6B1808
A6B61EC4E47BB6AC14B105FFA7ED6AE99A1CA0B360D1A5C24E0FBB55C66F5811
A5CD0625654654651979A8C4C3612054181CD300CD42D1D9CAAA589118D6C7CD
5EA8A9A0C639D5539430D40318F4B739DA281ABF2BE2765D44F45B218BB192E1
9EFBDDF7777E8730FA7DC0651BCD5D68EB743C51D9CED55403021D45F77CAB5E
7E892B3D1F875DA86C030A2387487DBAC8795749E849EC93439C9E22EB20D11D
07DA0F09EE9356D55B8D0D8555F1B0EC98C72863B376D3436E10DE2FB1AB9453
DADA019DCB64F6D059AB3A95B28B94435004C9A8BD3FB80E2B9DE0E330D03622
3AD965B4283E6DC880A2130185CDABC053C52693CE3F50557F524D7CCA9BE05B
FF9597ADF5D1C432C00C0B0D8EC2CA8436685B4BF3E2105B89FA6CC787B77637
248796C2F43872B3BFC8011159C22EDB7149AD8932360A88A223CC638BED257E
04908032ADA750F17279F7331189C322CB5ED9B66E502945BEB1EC68B1C7BCC0
2322EFD669C229B28CE1D0CBC0005FF967D0A4383E29538AFA13D41D484D739E
487D497DEAD8F661847A5D82D77D91219ACF666E565292384728E58E1A489054
8C3E34B413A6A550C499218E7FCF43694CBEAD016119CE85515F5EDAE3CD483B
A0F32743E7A189708AF0CB6FBAB22AC8F23604FFECE038C838472CA40ADEBF08
47AB1D450E07F9D51828D25DDCA679E3FAE54634A37AE1A5A778365C5A2C8A27
64085AC775AC132CCF27CA164C4721F67B63D52E388B17122F15E5DF391674CC
B6C9EDE307D79E390068970FE0AB210337558544E8CA59BD85F4DFDA1A69D18A
95EF6E1C8A6EFEBAF9D3D0CBFD6FA67EA64945440BE6F34771C491C607BFB199
7469D73961C0E8DAEC14FC13ECF37514DBF9C5A991943BDBF66C0ACA84BEDF8B
54AFD478D9695FCAA0E4FA51CC6C3A84D3D5904EBBD089B189203DF7239A2394
F2B5338FB0603488E278EE68F3CE7397B142062BCD6A62AFF936B2ACEF919E57
21FA55672F22685B5305F5E84900C327E20248F7DDEC431EDFEF8F922EFEBD58
EDDA265414D834391381C29CAC17FACD0A2F071460BE0D3DC7F6450E768DDF4A
D39B8E27065A8D236EE9643C209A36CBC8AB1D87C7B3FDEAEBE82AC779558FA9
15EFAB7C582B6CFAF3F8B174B1223D531067BA929EABBE1404DC599682276A0C
03309EBD39951A398883FC919A711E8E891F64657D64B43EAF4ACBAC482D06AF
D458F0DC3F4885030096DEA6AF7AD28E2DD526D66EF00BB3F4970C162A20E2A0
3AFFF9D6B0AF70E1D643784CCA5F0B76FA16D597879F762BF7CE394D18DC76D2
06301A735F3377789FDAFC843F9B3B635BC7871DBCF2B8BE5E7E6290AB1C4B10
165DE8C3E9109949A8FC60CB19EAADBDA8CE8FA7FCCEDE1BD4B8566A268801A7
2428B8193F4A9F02506DAA39886CAC4D93D6E6823E197EEFB4A340040C1C50BA
4952CFE767074B3615FDB279B9BCC0993871E9718A75DFFFC74395B532A58983
B7E3AB32A13A3DC4FAE0E34E485C31FB2952DAD2A611798A9B23C8C0EE5E1CDE
0C9307615D2E9E878FB834D9FAC5D75DF9C35CDF69EF9B3A8CB135C7722D415E
7E2706105A9C525F3B8816B0196E9F12636472F5845AF507937C0D6B5A9FAB91
FEB3260A1B119B4616703C7A02421BE4F6FD230086F1440BADBA4D67AB94B9AE
A4610A677E5847AD059551C2C0D11DBCCFB1B9657631C34E9374ABAB9645CB8B
AF03BC18D41A89D98DFF1E1AC62FBE8333BC44D2B83D65BA382812971B458EDC
4A896302D0BD6960EC93B33505DF478BDB6BC5FEEC5907086772F4BE1CBA7691
480D037E34425946440F9F29FE71635D62D4C3AF4C1DDBFD88BCEE48DD1A19A3
02235DE926D229F878B8A6B915A6831E9D000337F0ADC5EADD12659B3770745B
774D8799B5E8689F2965CCFBCA090FDC33F885179DAE71D904825B2164A55DBD
F4EECEF94DA40C621D4133C6B3F5AF97F434E3524EF72D4C5EE0DF31808CECB5
97CFFFBC8413DF7821859BB191D53398A26D610D53AE6A1B0D00F3123E5BB8AC
C107D8B722419A9C1F8EBE330CB0D27A17455260973FDF394D385E81DCFC02B7
C16CAA33050044E0A9AE1833F6EBC9A1374A20F1FE4122E7C46E94E0C3580377
4283C658B716F852E839CD586C01A5443002CFE126DF21A740D9791D4FD8CFD7
A7E7F43CB223DCAA3F7B016E18B0C7B457A7055B3CCB938263BB49B5A0E536FA
063D6D8C53508A79C1DE763D5802AB247E9FD612C7762E866A6E4C83D0AD28B7
6D08DA389E20EACCD3FC84E2E6F774AD9EBF63D76AD43EF38700BCE4FCAF84CD
0CB19D0AC4A438EA64D224F44F943F55F75330C1B8145C99DB8378B733B62ABF
80DCA3C9C76C59603F58C074D92E17607A31FA6C345042BBEBC8DCF1934A7DFB
B85B568FD06ED24B0288F8BAF750CA19101B2040FB6637140B8C664777B47738
3CCEA10984064D8C3E06DB55186A0366C3C7F006A854C447880648E6AB566B67
9222614788836217DF310B3392CCE274403A59FDF849A5DD01EEB67EDBC68B9D
89D8056D2F500E07CB52B6321F7F45C1AB3E90B348F1657F327D698A8A222DE5
8623B2BEDD2A56E4CEC34D583169C4918F791067417FDD3131DAE973FED07CB8
6786A6D5E41428143181B7E18278AB9D9AFBE313E2AA15FE976027B15E24EC8B
8568CF40BA5C1868021E69F6DCF2B27FF31EA794BC8B59C36F7A76B6B93D28A1
8CF021042D11CCC1BC769ADAA25B7075C6FD56077C00902CA6AAF0C12EB5696A
397F1ADB45A65DC61852339A38D7BC9D8529FD28B5750CB25B31026B49433392
C8930BD9661B23C2EC0E0BC3C5C8FBCAF232FC4C567CFD7F82EE726DBE6FC611
C0D8BC5CCAD3452A7FE5A527D3A9DDC1C8E5A1260E06EED5214EBAB9C299FA31
AFF925AB8F21B25AD1B102A76057255A7DF6BD8BA147130E2A1A77170EE1A71B
443530EFC2F6FE5FD80496B61CEF4FF35625C5F6E30F32C6028CA6D11849D17B
5DA8ED647B79AB412E0906BF106AC063E2B8EEA19EC3ADE5245DD627628FF45E
258DEBEFA61BA82047BD2C432A5BA403904CA67BD2A88B0282F50FD1EB2568CC
35D8A54FFA03883488B8B11ACA917354CD7B5811508053C9B5914FC368A6A648
F9AC90ED7B624CD4E5EB652F778F7942165179A307A636700139BD2029D0E69C
220DE636E9F3805D635255FEDB891F79982A075E7A1654FE5F9262B460B2222E
DD152AD19C307118AC0086653521EA59D671DAEF0D0D40D6063A7272A9D341BE
C0C11FCE9480BB224BA0644E95818D08106F5905F67C15DECBBD1CFFFAEA9914
BB1EB4AD55DF687B4C7F124920F46186D75F04A4B42F39A4935E10F10BAABF5F
AAAA47A65D369E5B82EC8B89271D9A6FA754A922516A672CE969C677363E157B
01E8B11BB02FB00762A522A3DF2BD02014DD937194ECD03E78CBB916BC57037D
BE008CF0C96946E89B0DDC70334FF6D7B4306A9FC5CD0C20E5435D64E8D96B6A
832F1921A69109587B8E9A97D2774EF4D5FBBE60CF59564075560F90D3EE32D6
E4F223319B772F7BD8C9170C54BDDBC96CA8BC788F1DC016E90C8F25C0E9AAF0
2B9595CA99132C0A5DE3BB012A4BB5158B708200F7FC77504661892F606F86E9
A9BC21D2AEC0A5816DEEEB676AF921ECCC3FE530747CDDD040941FFE4880D168
26475AFA3DDB9F36A73F493745262B66DE24124948758FB7D71189AFF28F5299
BE1019A7FDDD760E67967A9DCA43A0A0A735ED69CD3B7CA0111D56DD3EAD6560
1D0DAF484333C460BBB25244A0973EA0EE047A6401F342D83D5B566DBADFEDEB
F5FC0ADD5DE35F06EE958D9D415FE62EB0223676B51CCB12AA58F66963F95423
0978BD23BDF857215D9B2DE05BA12B3038E38676AFCDE9AD568319DC6F85E6AF
68ED69963DEF718D9B62EC9F830062205282FE62EFD18255C6213D3D1C305B12
996142A9019D9C51B5D8908CC83AD69B46600A6515C5F45D0E78BF2EC3E236B9
5EF9D81C629433729B8BD3D92EC5CAC7416E4ECCE80BE54C77342B004F82BA10
BBECF72DE976D89E57B8BF3BF048E96E8E3BC70F1EA0E1A5E0185A71AEA8FE63
A64949A7BD67443B94D9B9956F920CA79EF87A9603BC6CD402A087A940C32B30
3AEA6B90706004ECB3764B6430F0C5C49D39DCB7341656791C3D210014D0D6DD
89AF38C49D825AA74E181568A10B536F68B7A029278712C34ACFAC1A20170A3A
F187C72B119BE5F19E2D9777719D6D1D757855F77F9872FFEF1A8B62C4D0251F
21FF313C685D3F63E46DE52CC01A232C2456EE913CABB9B2A1C61767C50DA54B
5B97820B88A18B6F5E9C82246C7F9245D3F5719F7941EC91235F9F1B9276992A
3011D63ECEA906BEE8B178FA9743947F46A3C3678F4DBFBDF2697794E521E144
7DF673F327C0031F415662B8F9BBAD6B1DA2D5D8FCD132607964E58D19D8317B
77DCBC64B422AD14C3AAC6F89947D1C133FE9579F917E7D9FEAF0D748E301260
AFC494FD576D7570D2B23AC9628EF609B576D4DB2D94332D123175E1520110BB
89B934B8D75830E161BF09B3E6FAB30DAF0B747B6823E65853DF916BFAFE81C6
B54C998A5300154059A6489F3971B520D90C16950BAFB714FBDEBA2B5BE80E58
F854AD8F1848E96276DBBE67241DCADB48E6F789B5387B07C841BF938ED2CBE1
1CAF1A5D02435BBEC049EC4016390645D624E2D1F2863C640D5E0D23532A303B
350050F51CC00D7AB8FEB7CBCC58EA01F55F00D57E54C7EAABE035F2A19ADAE8
98B7F06CE566B5620FDDC0757D2D2A95344A9BC70F400C8112DE7DC2367523A4
5F31A9CC183C5CDCF006E69DB6FBC471250A976D27A691965FD1C3B0A09767B2
415C77C3E24CA627F36025A4E0E2E7CED9DC53EC1CF3EB23433E71FCCA930325
AAD1182D33808372D661F1F32132B41CB7A60B0919D3E9B990C1821696B26893
1B132DC6FBCB43DA0F7CB16D4B5D4B0055447EB90BA9494D2ECC8598CEBA8345
66A6F725ACE3043F9676E8F42867137EEE7A556651A455077D64B52C5FF4B802
50D312DBDF83DF956442CB14BD2C5658C938BC685FADEC8C6514A72AAA3B0386
2F2CCD410465A031E1FA28D2A327DFF5132DBDEEA132F5662F97BDC23F7979F8
02D54822CCEF7FB3CCFE6419EFA716E85BEBAB9938F99A2394F2B5338FB57853
415423D618A614D4829E16219EDFCDC202544F6E8CCB463D664FAF1E15D2819A
CC236CE307310AA50B88F2296F6A5EA2F0320C361E061DAF254B3AEF3ABB186A
71683C6CCF19C49E038F56DB0698B5AD852CBD82C7852FDB4B073A3D382C0D49
DB776D978DBEC0E0DB9C4D58AF9DAF6894363B2114294E66864446DAA5CE2591
12178CB1A32799A1A0B9AF369144E6C9CFC1E0006DCC04883A157EAE2DF25F91
2B8E435DEC67EE2B662A9898569E109D5B0CA31ECC9E312D8E321648A050AC22
86CF5467C760E8D9D8C08E54EA6E14879CB9DDE509DE41CB905AEA0B198118AF
E13B5BA35C5E30A79F2EF4EA833B4355EF2936AB2397727FE7560A171045EA8F
C0DE95A2237900FE4BC8F67755EBA2F10AADC60E5A80C4C16F5E835723B2DECE
B48DAD7400228FFFD7B3EC5AA8A7DEE35306E0646863CAEF11F6D086A450DD9E
DA44EF11CF5D68F5F0C72630DC53A4124D8CB66994DBD055AE853E873220D4E8
527C8DEB9C91F0578A14BE59C6E958A97C3A12E2D11A2E2E270919ED78674457
73EA68676A2A094A83A93E1EB4AF3BED9B084B73D57D0B44FA4C2E9ADD220E54
8D28891DA4C657C8EEC26EE01AEC796278D0583D9F91D8744EA122C23BF00ABA
0E7E6DB31277624295F91FD9A7C90BBB6B08AD2393EB82A417BD2D7204CB6E29
38DAFD0636499674E3B2E4885D4112F73FC36C74FB893CE2ED0895103E764B68
9AA7C45AA036678E7378CB1E9BD9C4505A2D4E2445C1936906A1A6DF0D346F84
37762EBE9A04F9815DB6DB1EB3472A1CFA532E87B80606CD824EF4FFBF0126FC
145DF78D7914CE23E67782513AF77B9F66D23136C74DC040F6F869848CBEDEF7
6AD7F14CB4E52051FD8443380BDF52C2B8F5123551A8DBC9C156A999A5D0C2A9
48A7CB3B61FB5A7780BA03287A47EB6D6088A51BF57BCD54D8950DB0CCF5273D
1672519474C73E72D926D5AC3A5D0251C29EDE7D844907727089A06B281093D2
34E345354209FB6AE63E77FE5B1AEB59179DCC59C7AAFFC8FE401179A005AD67
E642538CD7DC7ED01BFADF46DA47D177CDB1FAC0C4CF0DFA0B3309307F901AFE
C0709D6C3B0F62DA521CE05910846946C8345A342874B9C1DB138D504EAF7659
7028920C2450FC1AAFDD1A30A4F84A9C605EF4E304291B8B0DB68A5713BF5932
D5436310B1458521E361EBCDE1F4BFA13447D67086D02E584C5A5D91E1492CED
77CD96135535532D3DED7FD95F3CA8008D675F449BE07062A1E4BEAC028AD1EC
D0498EB69D0FECCBA90DA09C429F9FD4F74904C7106B6F8CD7C5D3D2B2EE4CF5
91CF933BD8B554D763E0F9026E29EB3647B4FD71E602D9D0C1289260B0E12B51
E1234E92FE3C35B73528643C2501AB8A806BDD62D1902620FC30D5E8C9BC7DEE
0B1985F37FC059FDF17CB7FAE2BAEFF582A3D80351CADC16CA6F221F51681275
E014C41A581DF0678CF31C5D103CA1E3C0EFD0020D69D043A9F0829E9EB5F682
01FCA37A67BAFCC4CF18A28683D7FCC19A5EBF00C824A28A0BD7610FB84427DB
4CEC6FBA789639792560A93CA44244A8CFE6152FBEE6473261769CB58D19FC8A
15EF2E869A13AAECC8D5B386218522C505EA8B33DE7F84B5CCA048A1AEA30DAB
C891C5DDC571FCB38B006A8B690E7B818974CE817503A631C88C9A9E4F56B7C1
F6417B810427A63160EFDF226AD4175F0202B68C507C4C5DB9E33952A62D116F
17473366E498C82811CDE551ECB3C8DCC93024F925D8D139E794EF005327144B
153EA73145B70786E04C33E332ABD6583D36F1FCA9535231C0766214E4ABE6A6
FBD131E169392206EA70C44A1ADA66DFB3442A5B0FE0A3EE34728C8D4F2D24A4
42059AF9BD19ED62116474872A5EF26045A25D03A3EEE450BFA2626DE4EEF2C2
FDAE4BB6D2905A7B6014F9498AE848C5C03733DF08E018AB31548EB39FB840FA
2CB3A107C818C398F60E15AE645B8BF1CDD5597BAE4D4700A54726D906264C82
E8AED7E4AC87D6715A493FFFC27F6AA52F79225868783A50546B12D2FF0E95FD
2E3EFC4BC51F799C62A8B86A7DB68B7EDCB0E042485D8916D491301D6F8F9E88
64D2E7440A64DAC8E6EB6A4F6A047A230D44CE6210E275C4AAC7931329F211F8
739A2B43BFA2363CA74FA72668FC761D1A17B9C3C536771EC35651395E03113F
FC2CED08DE4689EFEAA86918D112EF25B18BCBACFAF3132CAE0521421190E7DD
C50A50A33473F085EAB0A228BED6672645EE0E8E4EE80C99EC9B009467340A48
97CBE99413CF03E2FC6BA0228EB6F5505369467F0663C432F50075915A858725
501E387CBC5D5F34DCB7F5AAAD93595B98F931A57A544A146ADEA4A235441A4F
E65E49A815619A4F696665DE89A543A1FABD6896A0C405D26D6911D8E49A593F
43BFEA26263E16F6012B974D2061E761FC22C30FB659FD5A1933E26D4C37618F
76B73CE5E9924418E5025F9F79BC1AAD0208ACB0CE04316685304F54925F4947
EB67966E9B6F104FDDFF62E82B16CBE3D401AAFA4008C687015B182F1811D000
226A3706E7696D31CD8CF6735D4B754C6DD160206DBA83310D820B6904B356A9
2CC239A31644BF123DA78DD615C4287ED7DD43B679C2642290BB9D558E1BBF66
C0839F5FF759E791EF3D8B448AA279D64952A6D39CFFDBA38C11C7238C738370
C48FFBB00B9749C1033BF3AF51455B475EC9692E9E99F6A9098FADE1BC40550D
BD475801848196FF59D705A0D83B416F17475923D43279785B68529E668CFCB1
710F359EBC381F13C03AD805AA74F65566957680618C923BABB061A452FC4FB9
5130181253E90EEDE1268161B9A03DDC599C41F23C77C5072809B2819B32478F
D58A974363A321B620AC85CB745676F87833CC5803627C6DD6BE703FC0B6C4A0
4F78A0399AD1358F5C8A814CB377C8FA4482B834DF4322929D8632C4BD136C89
169D45718A88BABE2BC905E96349386689386BFABA5CFC0CE6369C638E695C22
01128706F71D3A9C29B4295B55CB4C6F62668E644C04646F79745A41552F95F7
4536C803FD0E67B1A00005F097161BEE88E98C10DD94824B57320819A1230FC4
401D1032BDEF5E854BD6FF18B37A143FC73D6E70DC12DE90730DADE2A1F8A6FB
AFE03DA1901290D4EA81FE1DA580CCB52FDE7CBFA758E990A77EBB8531FBA587
0ACB8E601B345BF60B9476896575B183432837193B3B149CE4A666C7A27E6AB9
D36967835A2F41B21629926169048962CF3BDA55B07D4D3832BC407B09833C77
DE4D96A569DA055E9CF9F820A737C02793B52B6C655084C19CFDD041E2553285
695835AED03705CC1A417293B98EAC6BB190766FC23ED05598B2F882688C2AB4
C31A8D808ECF0E0DC7020531A131A33F226AC1C285AEDD17434DE45ED8EB7F49
8371BAEDB7B887071B05C063479684A4C9E02B2F527B86D38762A9D056ABDD97
89A227876B606CC19287478BD26784654E136E8C7341C7EF670B6DA914E4300D
2BA8D46CD3CBEC0C7862DC44FE3BA78163A3D1697307F5446143F70DEE710BE3
8BC7533E3DB466E94E1984D0E057CA8DFEFF188BC1BB7B2C4F895C304A905961
B4191C5C797C9B510BF56372DD292A5453520C558DD6B8BA18DCC9E83AE5455F
5806B601F611C34A0F2EDE122AEABB87FADA2B0EF0ABC4A778C1BEF87753EB47
65A34CE7EFD49E189A5CCCD62E637498E9C202FF02C73DE33C5EF6AD45E91DD2
6021F815BF874EFCED58F878F32E4C8F5C47A8144B0FC659138A385F2006303E
2D6010F849FEF967D599E23CC2BD843EA2E70DD20C355F99EA300D24D96C0377
86FDA53F5FE95EECD98E347E00EF21A2D90008C99741210F7584071B06BF6FE1
B4C2120CE9864CCBF701E160845BF791E20ABF3DA5DA8C0A1B05164210F44597
316B19FF822A01787C835C271A6B74B4BFD7AB4EE1F16F6C67D01B97960376E7
D8C63FE77F59CE0530D742B751819ED6096BE8BC5C66A86DA1267E6DB218EB24
261FD00799478BAE4BA2FC7EA7E344CD3BCA0DB47EC6168473D0CEE52DA2C2A6
7C57BFAEC59BD3FA8BFBA7A6F3438F28E64B9E083E975E65E339C806C5EF81BC
DB1228B25B2D8DCEE5ED5772D6A4FD8405949F1F145F598C5C2F7620A1987668
C4D41E5158A3F1015A2B30A8D386232D0AF205AED4629ED00924160CDEA52AB0
42C68AAC9E9EE68C45C32B1F251CFED7A49D151D0D5C5D28EB4EF8C32F0252E6
FA2C5485D9A5AC63D0CC61F28581134896C3742E5C91C8BA9023A92D1FAE8788
BBEB84EFA65F5767D30E2444E365AF627F0D9CFE271333B20F30318C356CA864
20C6A7696F686D6E3CCC58A63E83F2E9CF7986ED0D7857E9E1724F3FF6192E62
A32E583FE772BEC50F0B999920A99F84EA4C097E7AFD44C20F4FEF9B7CAD9472
26ED83E339DCB913D861EAADF3E66B49C4FD14A6F1618CDC774CAC643C25BBFB
FB0CB55FE3DF22E26B56C6849E76B532979BDE3505CA5B2F312D9B93A638B9C0
83E1B05AB9957AD912AB1631A7E08069C51B027BCC51F7D4BF5272630C8CC3EC
66820990C731DFF08EF4C8187565D7E8E75BC40C923BE7D711F92AFBBD07DD8F
1E58EB45A9F60DB65B76088EFE8EC224C8F854A28F20FDCECF419A4CD15CFE36
B6901B7F66D2DBF20913D62AD2B03CADA9CCC7FE5357E089C3CABD4A04B6D762
01A36F6241AB9F0C237DA28E5A94FDDFBA18AE3F2044A4AAD5FB8B9740D46F5B
F0437C51B2FD7110CCEBF6F466C0D43163E787A4F3ED13A7192613C2B92884A5
9764CE444796A237E570D6EB1214FE86E57EBBB1EED2648A6C137AAE7EE7B850
DD08C25168A3E670E6D13BC51C95454EDF9EF5C44C3828E4AE27CBEFB9473F4F
5C15D5DD06D7E9C1807ADA0EE6CB97C57DBC29C4E904D25DBED1237E881438B9
9480B39510F96FD696398240DF656D5E8E1D82A7B2341B5E06A748E0E0CF3352
DD4B8872BA7EF5B20081D18F0D080A58EB2D0E6E328072C2EB092A1918D38FA1
BCEB3B9AACE3E99A15A02976944F5A5203DBA4BA89E0D63D0A42B2FBC407D887
4DC0F2516EB3B804D8960FF3A67B76FE4F4EEF614B3865600BAFAABEF8156103
443EA2B832786E623AA104C66CEC1401871A97F18572B8FDCEEA2B1CA5CE324E
140784FB7D8E64EB5F5D56CABCA6E0F1
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 40491153 11625907 1000 600 600 (diag1)
@start /Fa 22[37 111[42 42 1[42 42 23 32 28 42 42 42
42 65 23 2[23 42 42 28 37 42 37 42 37 13[46 2[46 6[28
3[51 60 55 14[42 42 42 42 3[28 5[28 36[46 2[{
 TeXBase1Encoding ReEncodeFont }36 83.022 /NimbusRomNo9L-Regu
rf /Fb 22[37 115[46 28 32 37 1[46 42 46 1[23 2[23 46
2[37 46 2[42 20[55 8[60 55 60 19[28 45[{ TeXBase1Encoding ReEncodeFont }
19 83.022 /NimbusRomNo9L-Medi rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
statusdict /setpageparams known { hsize vsize 0 1 statusdict begin {
setpageparams } stopped end } { true } ifelse { statusdict /setpage known
{ hsize vsize 1 statusdict begin { setpage } stopped pop end } if } if
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 TeXcolorgray Black 0 TeXcolorgray
-595 849 a
 currentpoint currentpoint translate 1 1 scale neg exch neg exch translate
 -595 849 a -568 128 a @beginspecial @setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ } def  1.13791 SLW 0  setgray  0. true 168.44019 84.78905 0.0 -83.65112
.5 Frame  gsave 3.0 -45.0 PtoC Shadow 0.25  setgray gsave fill grestore
stroke grestore gsave 0.87843 0.83529 0.31764  setrgbcolor gsave fill
grestore stroke grestore gsave 0.87843 0.83529 0.31764  setrgbcolor
fill grestore gsave 1.13791 SLW 0  setgray 0 setlinecap stroke  grestore
end


@endspecial @beginspecial @setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale false 0.4 1.4 1.50565 2.0 CLW mul add dup 2 div /w ED
mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto
0 0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a
sub moveto   EndArrow  } def /ArrowInside { } def  8.59277 SLW 0.56862
0.54117 0.54117  setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale false 0.4 1.4 1.50565 2.0 CLW mul add dup 2 div /w ED
mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto
0 0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a
sub moveto   EndArrow  } def /ArrowInside { } def  [ 221.3623 8.5359
171.85437 8.5359  /Lineto /lineto load def false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.50565 2.0  CLW mul
add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /Length x2
x1 sub y2 y1 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos
mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat
} ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto
} repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 8.59277
SLW 0.56862 0.54117 0.54117  setrgbcolor 0 setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale false 0.4 1.4 1.50565 2.0 CLW mul add dup 2 div /w ED
mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto
0 0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a
sub moveto   EndArrow  } def /ArrowInside { } def  8.59277 SLW 0.56078
0.54509 0.54509  setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale false 0.4 1.4 1.50565 2.0 CLW mul add dup 2 div /w ED
mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto
0 0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a
sub moveto   EndArrow  } def /ArrowInside { } def  [ 441.5867 8.5359
392.07877 8.5359  /Lineto /lineto load def false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.50565 2.0  CLW mul
add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /Length x2
x1 sub y2 y1 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos
mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat
} ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto
} repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 8.59277
SLW 0.56078 0.54509 0.54509  setrgbcolor 0 setlinecap stroke  grestore
end
 
@endspecial -568 128 a
 tx@Dict begin { 81.21031 69.13995 } PutCoor PutBegin  end
 -568 128 a -1007
149 a @beginspecial @setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ } def  1.13791 SLW 0  setgray  0. true 2.845 neg 4.87497 neg 108.76405
10.10988 .5 Frame  gsave 1.13791 SLW 0  setgray 0 setlinecap stroke
 grestore end
 
@endspecial Fb(A-La)20
b(phase)g(pr\351paratoir)o(e)-568 128 y
 tx@Dict begin PutEnd  end
 -568 128 a -568
128 a
 tx@Dict begin { 80.31248 34.42801 } PutCoor PutBegin  end
 -568 128 a -1180 147 a Fa(1-)g(Collecte)g(d'informations)e
(publiques)-568 128 y
 tx@Dict begin PutEnd  end
 -568 128 a -568 128 a
 tx@Dict begin { 70.87396 7.11317 } PutCoor PutBegin  end
 -568 128
a -1089 147 a Fa(2-)i(Cartographie)e(du)i(r\351seau)g(cible)-568
128 y
 tx@Dict begin PutEnd  end
 -568 128 a -568 128 a
 tx@Dict begin { 76.04431 -20.20163 } PutCoor PutBegin  end
 -568 128 a -1147 155 a Fa(3-)g
(Identi\002cation)f(des)h(vuln\351rabilit\351s)-568 128
y
 tx@Dict begin PutEnd  end
 -568 128 a -568 128 a
 tx@Dict begin { 75.99568 -46.3781 } PutCoor PutBegin  end
 -568 128 a -1134 155 a Fa(4-)g(Consolidation)f
(des)h(informations)-568 128 y
 tx@Dict begin PutEnd  end
 -568 128 a @beginspecial
@setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ } def  1.13791 SLW 0  setgray  0. true 388.66457 84.78905 220.22438
-83.65112 .5 Frame  gsave 3.0 -45.0 PtoC Shadow 0.25  setgray gsave
fill grestore stroke grestore gsave 0.9647 0.69411 0.69411  setrgbcolor
gsave fill grestore stroke grestore gsave 0.9647 0.69411 0.69411  setrgbcolor
fill grestore gsave 1.13791 SLW 0  setgray 0 setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ } def  1.13791 SLW 0  setgray  0. true 608.88853 84.78905 440.44833
-83.65112 .5 Frame  gsave 3.0 -45.0 PtoC Shadow 0.25  setgray gsave
fill grestore stroke grestore gsave 0.6549 0.76862 0.43137  setrgbcolor
gsave fill grestore stroke grestore gsave 0.6549 0.76862 0.43137  setrgbcolor
fill grestore gsave 1.13791 SLW 0  setgray 0 setlinecap stroke  grestore
end
 
@endspecial
-568 128 a
 tx@Dict begin { 302.19925 68.00203 } PutCoor PutBegin  end
 -568 128 a -1019 149 a @beginspecial @setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ } def  1.13791 SLW 0  setgray  0. true 2.845 neg 4.87497 neg 111.46373
10.10988 .5 Frame  gsave 1.13791 SLW 0  setgray 0 setlinecap stroke
 grestore end


@endspecial Fb(B-La)h(phase)g(de)g(r\351alisation)-568
128 y
 tx@Dict begin PutEnd  end
 -568 128 a -568 128 a
 tx@Dict begin { 526.30888 68.00203 } PutCoor PutBegin  end
 -568 128 a -1018 148 a @beginspecial
@setspecial
 tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ } def  1.13791 SLW 0  setgray  0. true 2.845 neg 4.87497 neg 111.2738
9.73495 .5 Frame  gsave 1.13791 SLW 0  setgray 0 setlinecap stroke
 grestore end
 
@endspecial Fb(C-La)f(phase)h(de)g(r)o(estitution)-568
128 y
 tx@Dict begin PutEnd  end
 -568 128 a -568 128 a
 tx@Dict begin { 286.31006 25.32292 } PutCoor PutBegin  end
 -568 128 a -1016 147 a Fa(1-)f(Conception)e
(des)j(attaques)-568 128 y
 tx@Dict begin PutEnd  end
 -568 128 a -568 128 a
 tx@Dict begin { 282.58458 -2.56064 } PutCoor PutBegin  end
 -568
128 a -986 155 a Fa(2-)f(Ex\351cution)e(des)i(sc\351narii)-568
128 y
 tx@Dict begin PutEnd  end
 -568 128 a -568 128 a
 tx@Dict begin { 291.25378 -31.58255 } PutCoor PutBegin  end
 -568 128 a -1058 155 a Fa(3-)g
(Consolidation)f(des)h(donn\351es)-568 128 y
 tx@Dict begin PutEnd  end
 -568 128
a -568 128 a
 tx@Dict begin { 523.60628 25.32292 } PutCoor PutBegin  end
 -568 128 a -1133 147 a Fa(1-)g(Synth\351se)g(des)g
(donn\351es)f(obtenues)-568 128 y
 tx@Dict begin PutEnd  end
 -568 128 a -568 128
a
 tx@Dict begin { 520.00496 -1.9919 } PutCoor PutBegin  end
 -568 128 a -1122 147 a Fa(2-)h(D\351\002nition)f(d'un)g(plan)h
(d'actions)-568 128 y
 tx@Dict begin PutEnd  end
 -568 128 a -568 128 a
 tx@Dict begin { 511.76254 -38.98012 } PutCoor PutBegin  end
 -568 128
a -1032 155 a Fa(3-)f(Pr\351sentation)h(des)g(r\351sultats)-568
128 y
 tx@Dict begin PutEnd  end
 -568 128 a -568 128 a
 tx@Dict begin { 489.49825 -15.6491 } PutCoor PutBegin  end
 -568 128 a -772 155 a Fa(correctrices)-568
128 y
 tx@Dict begin PutEnd  end
 -568 128 a -595 849 a
 currentpoint currentpoint translate 1 1 div 1 1 div scale neg exch
neg exch translate
 -595 849 a 0 TeXcolorgray
0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
